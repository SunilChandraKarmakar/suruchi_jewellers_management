{"ast":null,"code":"import { Component, ViewEncapsulation, ChangeDetectionStrategy, Input, EventEmitter, ElementRef, Output, ViewChild, Optional, TemplateRef, Renderer2, Host, forwardRef, ChangeDetectorRef, ContentChildren, NgModule } from '@angular/core';\nimport { Subject, BehaviorSubject, combineLatest, merge } from 'rxjs';\nimport { CdkVirtualScrollViewport, ScrollingModule } from '@angular/cdk/scrolling';\nimport { __decorate, __metadata } from 'tslib';\nimport { InputBoolean, isNotNil } from 'ng-zorro-antd/core/util';\nimport { startWith, takeUntil, switchMap } from 'rxjs/operators';\nimport { FocusMonitor, A11yModule } from '@angular/cdk/a11y';\nimport { Directionality, BidiModule } from '@angular/cdk/bidi';\nimport { BACKSPACE, ESCAPE, TAB, SPACE, ENTER, DOWN_ARROW, UP_ARROW } from '@angular/cdk/keycodes';\nimport { CdkOverlayOrigin, CdkConnectedOverlay, OverlayModule } from '@angular/cdk/overlay';\nimport { Platform, PlatformModule } from '@angular/cdk/platform';\nimport { COMPOSITION_BUFFER_MODE, NG_VALUE_ACCESSOR, FormsModule } from '@angular/forms';\nimport { zoomMotion, slideMotion } from 'ng-zorro-antd/core/animation';\nimport { NzConfigService, WithConfig } from 'ng-zorro-antd/core/config';\nimport { NzNoAnimationDirective, NzNoAnimationModule } from 'ng-zorro-antd/core/no-animation';\nimport { CommonModule } from '@angular/common';\nimport { NzOutletModule } from 'ng-zorro-antd/core/outlet';\nimport { NzOverlayModule } from 'ng-zorro-antd/core/overlay';\nimport { ɵNzTransitionPatchModule } from 'ng-zorro-antd/core/transition-patch';\nimport { NzEmptyModule } from 'ng-zorro-antd/empty';\nimport { NzI18nModule } from 'ng-zorro-antd/i18n';\nimport { NzIconModule } from 'ng-zorro-antd/icon';\n\n/**\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://github.com/NG-ZORRO/ng-zorro-antd/blob/master/LICENSE\n */\nclass NzOptionGroupComponent {\n  constructor() {\n    this.nzLabel = null;\n    this.changes = new Subject();\n  }\n  ngOnChanges() {\n    this.changes.next();\n  }\n}\n/**\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://github.com/NG-ZORRO/ng-zorro-antd/blob/master/LICENSE\n */\nclass NzOptionContainerComponent {\n  constructor(elementRef) {\n    this.elementRef = elementRef;\n    this.notFoundContent = undefined;\n    this.menuItemSelectedIcon = null;\n    this.dropdownRender = null;\n    this.activatedValue = null;\n    this.listOfSelectedValue = [];\n    this.mode = 'default';\n    this.matchWidth = true;\n    this.itemSize = 32;\n    this.maxItemLength = 8;\n    this.listOfContainerItem = [];\n    this.itemClick = new EventEmitter();\n    this.scrollToBottom = new EventEmitter();\n    this.scrolledIndex = 0;\n    // TODO: move to host after View Engine deprecation\n    this.elementRef.nativeElement.classList.add('ant-select-dropdown');\n  }\n  onItemClick(value) {\n    this.itemClick.emit(value);\n  }\n  onItemHover(value) {\n    // TODO: keydown.enter won't activate this value\n    this.activatedValue = value;\n  }\n  trackValue(_index, option) {\n    return option.key;\n  }\n  onScrolledIndexChange(index) {\n    this.scrolledIndex = index;\n    if (index === this.listOfContainerItem.length - this.maxItemLength) {\n      this.scrollToBottom.emit();\n    }\n  }\n  scrollToActivatedValue() {\n    const index = this.listOfContainerItem.findIndex(item => this.compareWith(item.key, this.activatedValue));\n    if (index < this.scrolledIndex || index >= this.scrolledIndex + this.maxItemLength) {\n      this.cdkVirtualScrollViewport.scrollToIndex(index || 0);\n    }\n  }\n  ngOnChanges(changes) {\n    const {\n      listOfContainerItem,\n      activatedValue\n    } = changes;\n    if (listOfContainerItem || activatedValue) {\n      this.scrollToActivatedValue();\n    }\n  }\n  ngAfterViewInit() {\n    setTimeout(() => this.scrollToActivatedValue());\n  }\n}\n/**\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://github.com/NG-ZORRO/ng-zorro-antd/blob/master/LICENSE\n */\nlet NzOptionComponent = /*#__PURE__*/(() => {\n  class NzOptionComponent {\n    constructor(nzOptionGroupComponent) {\n      this.nzOptionGroupComponent = nzOptionGroupComponent;\n      this.destroy$ = new Subject();\n      this.changes = new Subject();\n      this.groupLabel = null;\n      this.nzLabel = null;\n      this.nzValue = null;\n      this.nzDisabled = false;\n      this.nzHide = false;\n      this.nzCustomContent = false;\n    }\n    ngOnInit() {\n      if (this.nzOptionGroupComponent) {\n        this.nzOptionGroupComponent.changes.pipe(startWith(true), takeUntil(this.destroy$)).subscribe(() => {\n          this.groupLabel = this.nzOptionGroupComponent.nzLabel;\n        });\n      }\n    }\n    ngOnChanges() {\n      this.changes.next();\n    }\n    ngOnDestroy() {\n      this.destroy$.next();\n      this.destroy$.complete();\n    }\n  }\n  __decorate([InputBoolean(), __metadata(\"design:type\", Object)], NzOptionComponent.prototype, \"nzDisabled\", void 0);\n  __decorate([InputBoolean(), __metadata(\"design:type\", Object)], NzOptionComponent.prototype, \"nzHide\", void 0);\n  __decorate([InputBoolean(), __metadata(\"design:type\", Object)], NzOptionComponent.prototype, \"nzCustomContent\", void 0);\n\n  /**\n   * Use of this source code is governed by an MIT-style license that can be\n   * found in the LICENSE file at https://github.com/NG-ZORRO/ng-zorro-antd/blob/master/LICENSE\n   */\n  return NzOptionComponent;\n})();\nclass NzSelectSearchComponent {\n  constructor(elementRef, renderer, focusMonitor) {\n    this.elementRef = elementRef;\n    this.renderer = renderer;\n    this.focusMonitor = focusMonitor;\n    this.disabled = false;\n    this.mirrorSync = false;\n    this.showInput = true;\n    this.focusTrigger = false;\n    this.value = '';\n    this.autofocus = false;\n    this.valueChange = new EventEmitter();\n    this.isComposingChange = new EventEmitter();\n    // TODO: move to host after View Engine deprecation\n    this.elementRef.nativeElement.classList.add('ant-select-selection-search');\n  }\n  setCompositionState(isComposing) {\n    this.isComposingChange.next(isComposing);\n  }\n  onValueChange(value) {\n    this.value = value;\n    this.valueChange.next(value);\n    if (this.mirrorSync) {\n      this.syncMirrorWidth();\n    }\n  }\n  clearInputValue() {\n    const inputDOM = this.inputElement.nativeElement;\n    inputDOM.value = '';\n    this.onValueChange('');\n  }\n  syncMirrorWidth() {\n    const mirrorDOM = this.mirrorElement.nativeElement;\n    const hostDOM = this.elementRef.nativeElement;\n    const inputDOM = this.inputElement.nativeElement;\n    this.renderer.removeStyle(hostDOM, 'width');\n    mirrorDOM.innerHTML = this.renderer.createText(`${inputDOM.value}&nbsp;`);\n    this.renderer.setStyle(hostDOM, 'width', `${mirrorDOM.scrollWidth}px`);\n  }\n  focus() {\n    this.focusMonitor.focusVia(this.inputElement, 'keyboard');\n  }\n  blur() {\n    this.inputElement.nativeElement.blur();\n  }\n  ngOnChanges(changes) {\n    const inputDOM = this.inputElement.nativeElement;\n    const {\n      focusTrigger,\n      showInput\n    } = changes;\n    if (showInput) {\n      if (this.showInput) {\n        this.renderer.removeAttribute(inputDOM, 'readonly');\n      } else {\n        this.renderer.setAttribute(inputDOM, 'readonly', 'readonly');\n      }\n    }\n    // IE11 cannot input value if focused before removing readonly\n    if (focusTrigger && focusTrigger.currentValue === true && focusTrigger.previousValue === false) {\n      inputDOM.focus();\n    }\n  }\n  ngAfterViewInit() {\n    if (this.mirrorSync) {\n      this.syncMirrorWidth();\n    }\n    if (this.autofocus) {\n      this.focus();\n    }\n  }\n}\n/**\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://github.com/NG-ZORRO/ng-zorro-antd/blob/master/LICENSE\n */\nclass NzSelectTopControlComponent {\n  constructor(elementRef, noAnimation) {\n    this.elementRef = elementRef;\n    this.noAnimation = noAnimation;\n    this.showSearch = false;\n    this.placeHolder = null;\n    this.open = false;\n    this.maxTagCount = Infinity;\n    this.autofocus = false;\n    this.disabled = false;\n    this.mode = 'default';\n    this.customTemplate = null;\n    this.maxTagPlaceholder = null;\n    this.removeIcon = null;\n    this.listOfTopItem = [];\n    this.tokenSeparators = [];\n    this.tokenize = new EventEmitter();\n    this.inputValueChange = new EventEmitter();\n    this.animationEnd = new EventEmitter();\n    this.deleteItem = new EventEmitter();\n    this.listOfSlicedItem = [];\n    this.isShowPlaceholder = true;\n    this.isShowSingleLabel = false;\n    this.isComposing = false;\n    this.inputValue = null;\n    // TODO: move to host after View Engine deprecation\n    this.elementRef.nativeElement.classList.add('ant-select-selector');\n  }\n  onHostKeydown(e) {\n    const inputValue = e.target.value;\n    if (e.keyCode === BACKSPACE && this.mode !== 'default' && !inputValue && this.listOfTopItem.length > 0) {\n      e.preventDefault();\n      this.onDeleteItem(this.listOfTopItem[this.listOfTopItem.length - 1]);\n    }\n  }\n  updateTemplateVariable() {\n    const isSelectedValueEmpty = this.listOfTopItem.length === 0;\n    this.isShowPlaceholder = isSelectedValueEmpty && !this.isComposing && !this.inputValue;\n    this.isShowSingleLabel = !isSelectedValueEmpty && !this.isComposing && !this.inputValue;\n  }\n  isComposingChange(isComposing) {\n    this.isComposing = isComposing;\n    this.updateTemplateVariable();\n  }\n  onInputValueChange(value) {\n    if (value !== this.inputValue) {\n      this.inputValue = value;\n      this.updateTemplateVariable();\n      this.inputValueChange.emit(value);\n      this.tokenSeparate(value, this.tokenSeparators);\n    }\n  }\n  tokenSeparate(inputValue, tokenSeparators) {\n    const includesSeparators = (str, separators) => {\n      // tslint:disable-next-line:prefer-for-of\n      for (let i = 0; i < separators.length; ++i) {\n        if (str.lastIndexOf(separators[i]) > 0) {\n          return true;\n        }\n      }\n      return false;\n    };\n    const splitBySeparators = (str, separators) => {\n      const reg = new RegExp(`[${separators.join()}]`);\n      const array = str.split(reg).filter(token => token);\n      return [...new Set(array)];\n    };\n    if (inputValue && inputValue.length && tokenSeparators.length && this.mode !== 'default' && includesSeparators(inputValue, tokenSeparators)) {\n      const listOfLabel = splitBySeparators(inputValue, tokenSeparators);\n      this.tokenize.next(listOfLabel);\n    }\n  }\n  clearInputValue() {\n    if (this.nzSelectSearchComponent) {\n      this.nzSelectSearchComponent.clearInputValue();\n    }\n  }\n  focus() {\n    if (this.nzSelectSearchComponent) {\n      this.nzSelectSearchComponent.focus();\n    }\n  }\n  blur() {\n    if (this.nzSelectSearchComponent) {\n      this.nzSelectSearchComponent.blur();\n    }\n  }\n  trackValue(_index, option) {\n    return option.nzValue;\n  }\n  onDeleteItem(item) {\n    if (!this.disabled && !item.nzDisabled) {\n      this.deleteItem.next(item);\n    }\n  }\n  onAnimationEnd() {\n    this.animationEnd.next();\n  }\n  ngOnChanges(changes) {\n    const {\n      listOfTopItem,\n      maxTagCount,\n      customTemplate,\n      maxTagPlaceholder\n    } = changes;\n    if (listOfTopItem) {\n      this.updateTemplateVariable();\n    }\n    if (listOfTopItem || maxTagCount || customTemplate || maxTagPlaceholder) {\n      const listOfSlicedItem = this.listOfTopItem.slice(0, this.maxTagCount).map(o => {\n        return {\n          nzLabel: o.nzLabel,\n          nzValue: o.nzValue,\n          nzDisabled: o.nzDisabled,\n          contentTemplateOutlet: this.customTemplate,\n          contentTemplateOutletContext: o\n        };\n      });\n      if (this.listOfTopItem.length > this.maxTagCount) {\n        const exceededLabel = `+ ${this.listOfTopItem.length - this.maxTagCount} ...`;\n        const listOfSelectedValue = this.listOfTopItem.map(item => item.nzValue);\n        const exceededItem = {\n          nzLabel: exceededLabel,\n          nzValue: '$$__nz_exceeded_item',\n          nzDisabled: true,\n          contentTemplateOutlet: this.maxTagPlaceholder,\n          contentTemplateOutletContext: listOfSelectedValue.slice(this.maxTagCount)\n        };\n        listOfSlicedItem.push(exceededItem);\n      }\n      this.listOfSlicedItem = listOfSlicedItem;\n    }\n  }\n}\n/**\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://github.com/NG-ZORRO/ng-zorro-antd/blob/master/LICENSE\n */\nconst defaultFilterOption = (searchValue, item) => {\n  if (item && item.nzLabel) {\n    return item.nzLabel.toLowerCase().indexOf(searchValue.toLowerCase()) > -1;\n  } else {\n    return false;\n  }\n};\nconst ɵ0 = defaultFilterOption;\nconst NZ_CONFIG_MODULE_NAME = 'select';\nlet NzSelectComponent = /*#__PURE__*/(() => {\n  class NzSelectComponent {\n    constructor(nzConfigService, cdr, elementRef, platform, focusMonitor, directionality, noAnimation) {\n      this.nzConfigService = nzConfigService;\n      this.cdr = cdr;\n      this.elementRef = elementRef;\n      this.platform = platform;\n      this.focusMonitor = focusMonitor;\n      this.directionality = directionality;\n      this.noAnimation = noAnimation;\n      this._nzModuleName = NZ_CONFIG_MODULE_NAME;\n      this.nzSize = 'default';\n      this.nzOptionHeightPx = 32;\n      this.nzOptionOverflowSize = 8;\n      this.nzDropdownClassName = null;\n      this.nzDropdownMatchSelectWidth = true;\n      this.nzDropdownStyle = null;\n      this.nzNotFoundContent = undefined;\n      this.nzPlaceHolder = null;\n      this.nzMaxTagCount = Infinity;\n      this.nzDropdownRender = null;\n      this.nzCustomTemplate = null;\n      this.nzSuffixIcon = null;\n      this.nzClearIcon = null;\n      this.nzRemoveIcon = null;\n      this.nzMenuItemSelectedIcon = null;\n      this.nzTokenSeparators = [];\n      this.nzMaxTagPlaceholder = null;\n      this.nzMaxMultipleCount = Infinity;\n      this.nzMode = 'default';\n      this.nzFilterOption = defaultFilterOption;\n      this.compareWith = (o1, o2) => o1 === o2;\n      this.nzAllowClear = false;\n      this.nzBorderless = false;\n      this.nzShowSearch = false;\n      this.nzLoading = false;\n      this.nzAutoFocus = false;\n      this.nzAutoClearSearchValue = true;\n      this.nzServerSearch = false;\n      this.nzDisabled = false;\n      this.nzOpen = false;\n      this.nzOptions = [];\n      this.nzOnSearch = new EventEmitter();\n      this.nzScrollToBottom = new EventEmitter();\n      this.nzOpenChange = new EventEmitter();\n      this.nzBlur = new EventEmitter();\n      this.nzFocus = new EventEmitter();\n      this.listOfValue$ = new BehaviorSubject([]);\n      this.listOfTemplateItem$ = new BehaviorSubject([]);\n      this.listOfTagAndTemplateItem = [];\n      this.searchValue = '';\n      this.isReactiveDriven = false;\n      this.destroy$ = new Subject();\n      this.onChange = () => {};\n      this.onTouched = () => {};\n      this.dropDownPosition = 'bottom';\n      this.triggerWidth = null;\n      this.listOfContainerItem = [];\n      this.listOfTopItem = [];\n      this.activatedValue = null;\n      this.listOfValue = [];\n      this.focused = false;\n      this.dir = 'ltr';\n      // TODO: move to host after View Engine deprecation\n      this.elementRef.nativeElement.classList.add('ant-select');\n    }\n    set nzShowArrow(value) {\n      this._nzShowArrow = value;\n    }\n    get nzShowArrow() {\n      return this._nzShowArrow === undefined ? this.nzMode === 'default' : this._nzShowArrow;\n    }\n    generateTagItem(value) {\n      return {\n        nzValue: value,\n        nzLabel: value,\n        type: 'item'\n      };\n    }\n    onItemClick(value) {\n      this.activatedValue = value;\n      if (this.nzMode === 'default') {\n        if (this.listOfValue.length === 0 || !this.compareWith(this.listOfValue[0], value)) {\n          this.updateListOfValue([value]);\n        }\n        this.setOpenState(false);\n      } else {\n        const targetIndex = this.listOfValue.findIndex(o => this.compareWith(o, value));\n        if (targetIndex !== -1) {\n          const listOfValueAfterRemoved = this.listOfValue.filter((_, i) => i !== targetIndex);\n          this.updateListOfValue(listOfValueAfterRemoved);\n        } else if (this.listOfValue.length < this.nzMaxMultipleCount) {\n          const listOfValueAfterAdded = [...this.listOfValue, value];\n          this.updateListOfValue(listOfValueAfterAdded);\n        }\n        this.focus();\n        if (this.nzAutoClearSearchValue) {\n          this.clearInput();\n        }\n      }\n    }\n    onItemDelete(item) {\n      const listOfSelectedValue = this.listOfValue.filter(v => !this.compareWith(v, item.nzValue));\n      this.updateListOfValue(listOfSelectedValue);\n      this.clearInput();\n    }\n    onHostClick() {\n      if (this.nzOpen && this.nzShowSearch || this.nzDisabled) {\n        return;\n      }\n      this.setOpenState(!this.nzOpen);\n    }\n    updateListOfContainerItem() {\n      let listOfContainerItem = this.listOfTagAndTemplateItem.filter(item => !item.nzHide).filter(item => {\n        if (!this.nzServerSearch && this.searchValue) {\n          return this.nzFilterOption(this.searchValue, item);\n        } else {\n          return true;\n        }\n      });\n      if (this.nzMode === 'tags' && this.searchValue) {\n        const matchedItem = this.listOfTagAndTemplateItem.find(item => item.nzLabel === this.searchValue);\n        if (!matchedItem) {\n          const tagItem = this.generateTagItem(this.searchValue);\n          listOfContainerItem = [tagItem, ...listOfContainerItem];\n          this.activatedValue = tagItem.nzValue;\n        } else {\n          this.activatedValue = matchedItem.nzValue;\n        }\n      }\n      const activatedItem = listOfContainerItem.find(item => this.compareWith(item.nzValue, this.listOfValue[0])) || listOfContainerItem[0];\n      this.activatedValue = activatedItem && activatedItem.nzValue || null;\n      let listOfGroupLabel = [];\n      if (this.isReactiveDriven) {\n        listOfGroupLabel = [...new Set(this.nzOptions.filter(o => o.groupLabel).map(o => o.groupLabel))];\n      } else {\n        if (this.listOfNzOptionGroupComponent) {\n          listOfGroupLabel = this.listOfNzOptionGroupComponent.map(o => o.nzLabel);\n        }\n      }\n      /** insert group item **/\n      listOfGroupLabel.forEach(label => {\n        const index = listOfContainerItem.findIndex(item => label === item.groupLabel);\n        if (index > -1) {\n          const groupItem = {\n            groupLabel: label,\n            type: 'group',\n            key: label\n          };\n          listOfContainerItem.splice(index, 0, groupItem);\n        }\n      });\n      this.listOfContainerItem = [...listOfContainerItem];\n      this.updateCdkConnectedOverlayPositions();\n    }\n    clearInput() {\n      this.nzSelectTopControlComponent.clearInputValue();\n    }\n    updateListOfValue(listOfValue) {\n      const covertListToModel = (list, mode) => {\n        if (mode === 'default') {\n          if (list.length > 0) {\n            return list[0];\n          } else {\n            return null;\n          }\n        } else {\n          return list;\n        }\n      };\n      const model = covertListToModel(listOfValue, this.nzMode);\n      if (this.value !== model) {\n        this.listOfValue = listOfValue;\n        this.listOfValue$.next(listOfValue);\n        this.value = model;\n        this.onChange(this.value);\n      }\n    }\n    onTokenSeparate(listOfLabel) {\n      const listOfMatchedValue = this.listOfTagAndTemplateItem.filter(item => listOfLabel.findIndex(label => label === item.nzLabel) !== -1).map(item => item.nzValue).filter(item => this.listOfValue.findIndex(v => this.compareWith(v, item)) === -1);\n      if (this.nzMode === 'multiple') {\n        this.updateListOfValue([...this.listOfValue, ...listOfMatchedValue]);\n      } else if (this.nzMode === 'tags') {\n        const listOfUnMatchedLabel = listOfLabel.filter(label => this.listOfTagAndTemplateItem.findIndex(item => item.nzLabel === label) === -1);\n        this.updateListOfValue([...this.listOfValue, ...listOfMatchedValue, ...listOfUnMatchedLabel]);\n      }\n      this.clearInput();\n    }\n    onOverlayKeyDown(e) {\n      if (e.keyCode === ESCAPE) {\n        this.setOpenState(false);\n      }\n    }\n    onKeyDown(e) {\n      if (this.nzDisabled) {\n        return;\n      }\n      const listOfFilteredOptionNotDisabled = this.listOfContainerItem.filter(item => item.type === 'item').filter(item => !item.nzDisabled);\n      const activatedIndex = listOfFilteredOptionNotDisabled.findIndex(item => this.compareWith(item.nzValue, this.activatedValue));\n      switch (e.keyCode) {\n        case UP_ARROW:\n          e.preventDefault();\n          if (this.nzOpen) {\n            const preIndex = activatedIndex > 0 ? activatedIndex - 1 : listOfFilteredOptionNotDisabled.length - 1;\n            this.activatedValue = listOfFilteredOptionNotDisabled[preIndex].nzValue;\n          }\n          break;\n        case DOWN_ARROW:\n          e.preventDefault();\n          if (this.nzOpen) {\n            const nextIndex = activatedIndex < listOfFilteredOptionNotDisabled.length - 1 ? activatedIndex + 1 : 0;\n            this.activatedValue = listOfFilteredOptionNotDisabled[nextIndex].nzValue;\n          } else {\n            this.setOpenState(true);\n          }\n          break;\n        case ENTER:\n          e.preventDefault();\n          if (this.nzOpen) {\n            if (isNotNil(this.activatedValue)) {\n              this.onItemClick(this.activatedValue);\n            }\n          } else {\n            this.setOpenState(true);\n          }\n          break;\n        case SPACE:\n          if (!this.nzOpen) {\n            this.setOpenState(true);\n            e.preventDefault();\n          }\n          break;\n        case TAB:\n          this.setOpenState(false);\n          break;\n        case ESCAPE:\n          /**\n           * Skip the ESCAPE processing, it will be handled in {@link onOverlayKeyDown}.\n           */\n          break;\n        default:\n          if (!this.nzOpen) {\n            this.setOpenState(true);\n          }\n      }\n    }\n    setOpenState(value) {\n      if (this.nzOpen !== value) {\n        this.nzOpen = value;\n        this.nzOpenChange.emit(value);\n        this.onOpenChange();\n        this.cdr.markForCheck();\n      }\n    }\n    onOpenChange() {\n      this.updateCdkConnectedOverlayStatus();\n      this.clearInput();\n    }\n    onInputValueChange(value) {\n      this.searchValue = value;\n      this.updateListOfContainerItem();\n      this.nzOnSearch.emit(value);\n      this.updateCdkConnectedOverlayPositions();\n    }\n    onClearSelection() {\n      this.updateListOfValue([]);\n    }\n    onClickOutside(event) {\n      if (!this.elementRef.nativeElement.contains(event.target)) {\n        this.setOpenState(false);\n      }\n    }\n    focus() {\n      this.nzSelectTopControlComponent.focus();\n    }\n    blur() {\n      this.nzSelectTopControlComponent.blur();\n    }\n    onPositionChange(position) {\n      this.dropDownPosition = position.connectionPair.originY;\n    }\n    updateCdkConnectedOverlayStatus() {\n      if (this.platform.isBrowser && this.originElement.nativeElement) {\n        this.triggerWidth = this.originElement.nativeElement.getBoundingClientRect().width;\n      }\n    }\n    updateCdkConnectedOverlayPositions() {\n      if (this.cdkConnectedOverlay.overlayRef) {\n        this.cdkConnectedOverlay.overlayRef.updatePosition();\n      }\n    }\n    writeValue(modelValue) {\n      /** https://github.com/angular/angular/issues/14988 **/\n      if (this.value !== modelValue) {\n        this.value = modelValue;\n        const covertModelToList = (model, mode) => {\n          if (model === null || model === undefined) {\n            return [];\n          } else if (mode === 'default') {\n            return [model];\n          } else {\n            return model;\n          }\n        };\n        const listOfValue = covertModelToList(modelValue, this.nzMode);\n        this.listOfValue = listOfValue;\n        this.listOfValue$.next(listOfValue);\n        this.cdr.markForCheck();\n      }\n    }\n    registerOnChange(fn) {\n      this.onChange = fn;\n    }\n    registerOnTouched(fn) {\n      this.onTouched = fn;\n    }\n    setDisabledState(disabled) {\n      this.nzDisabled = disabled;\n      if (disabled) {\n        this.setOpenState(false);\n      }\n      this.cdr.markForCheck();\n    }\n    ngOnChanges(changes) {\n      const {\n        nzOpen,\n        nzDisabled,\n        nzOptions\n      } = changes;\n      if (nzOpen) {\n        this.onOpenChange();\n      }\n      if (nzDisabled && this.nzDisabled) {\n        this.setOpenState(false);\n      }\n      if (nzOptions) {\n        this.isReactiveDriven = true;\n        const listOfOptions = this.nzOptions || [];\n        const listOfTransformedItem = listOfOptions.map(item => {\n          return {\n            template: item.label instanceof TemplateRef ? item.label : null,\n            nzLabel: typeof item.label === 'string' ? item.label : null,\n            nzValue: item.value,\n            nzDisabled: item.disabled || false,\n            nzHide: item.hide || false,\n            nzCustomContent: item.label instanceof TemplateRef,\n            groupLabel: item.groupLabel || null,\n            type: 'item',\n            key: item.value\n          };\n        });\n        this.listOfTemplateItem$.next(listOfTransformedItem);\n      }\n    }\n    ngOnInit() {\n      var _a;\n      this.focusMonitor.monitor(this.elementRef, true).pipe(takeUntil(this.destroy$)).subscribe(focusOrigin => {\n        if (!focusOrigin) {\n          this.focused = false;\n          this.cdr.markForCheck();\n          this.nzBlur.emit();\n          Promise.resolve().then(() => {\n            this.onTouched();\n          });\n        } else {\n          this.focused = true;\n          this.cdr.markForCheck();\n          this.nzFocus.emit();\n        }\n      });\n      combineLatest([this.listOfValue$, this.listOfTemplateItem$]).pipe(takeUntil(this.destroy$)).subscribe(([listOfSelectedValue, listOfTemplateItem]) => {\n        const listOfTagItem = listOfSelectedValue.filter(() => this.nzMode === 'tags').filter(value => listOfTemplateItem.findIndex(o => this.compareWith(o.nzValue, value)) === -1).map(value => this.listOfTopItem.find(o => this.compareWith(o.nzValue, value)) || this.generateTagItem(value));\n        this.listOfTagAndTemplateItem = [...listOfTemplateItem, ...listOfTagItem];\n        this.listOfTopItem = this.listOfValue.map(v => [...this.listOfTagAndTemplateItem, ...this.listOfTopItem].find(item => this.compareWith(v, item.nzValue))).filter(item => !!item);\n        this.updateListOfContainerItem();\n      });\n      (_a = this.directionality.change) === null || _a === void 0 ? void 0 : _a.pipe(takeUntil(this.destroy$)).subscribe(direction => {\n        this.dir = direction;\n        this.cdr.detectChanges();\n      });\n      this.dir = this.directionality.value;\n    }\n    ngAfterViewInit() {\n      this.updateCdkConnectedOverlayStatus();\n    }\n    ngAfterContentInit() {\n      if (!this.isReactiveDriven) {\n        merge(this.listOfNzOptionGroupComponent.changes, this.listOfNzOptionComponent.changes).pipe(startWith(true), switchMap(() => merge(...[this.listOfNzOptionComponent.changes, this.listOfNzOptionGroupComponent.changes, ...this.listOfNzOptionComponent.map(option => option.changes), ...this.listOfNzOptionGroupComponent.map(option => option.changes)]).pipe(startWith(true))), takeUntil(this.destroy$)).subscribe(() => {\n          const listOfOptionInterface = this.listOfNzOptionComponent.toArray().map(item => {\n            const {\n              template,\n              nzLabel,\n              nzValue,\n              nzDisabled,\n              nzHide,\n              nzCustomContent,\n              groupLabel\n            } = item;\n            return {\n              template,\n              nzLabel,\n              nzValue,\n              nzDisabled,\n              nzHide,\n              nzCustomContent,\n              groupLabel,\n              type: 'item',\n              key: nzValue\n            };\n          });\n          this.listOfTemplateItem$.next(listOfOptionInterface);\n          this.cdr.markForCheck();\n        });\n      }\n    }\n    ngOnDestroy() {\n      this.destroy$.next();\n      this.destroy$.complete();\n    }\n  }\n  __decorate([WithConfig(), __metadata(\"design:type\", Object)], NzSelectComponent.prototype, \"nzSuffixIcon\", void 0);\n  __decorate([InputBoolean(), __metadata(\"design:type\", Object)], NzSelectComponent.prototype, \"nzAllowClear\", void 0);\n  __decorate([WithConfig(), InputBoolean(), __metadata(\"design:type\", Object)], NzSelectComponent.prototype, \"nzBorderless\", void 0);\n  __decorate([InputBoolean(), __metadata(\"design:type\", Object)], NzSelectComponent.prototype, \"nzShowSearch\", void 0);\n  __decorate([InputBoolean(), __metadata(\"design:type\", Object)], NzSelectComponent.prototype, \"nzLoading\", void 0);\n  __decorate([InputBoolean(), __metadata(\"design:type\", Object)], NzSelectComponent.prototype, \"nzAutoFocus\", void 0);\n  __decorate([InputBoolean(), __metadata(\"design:type\", Object)], NzSelectComponent.prototype, \"nzAutoClearSearchValue\", void 0);\n  __decorate([InputBoolean(), __metadata(\"design:type\", Object)], NzSelectComponent.prototype, \"nzServerSearch\", void 0);\n  __decorate([InputBoolean(), __metadata(\"design:type\", Object)], NzSelectComponent.prototype, \"nzDisabled\", void 0);\n  __decorate([InputBoolean(), __metadata(\"design:type\", Object)], NzSelectComponent.prototype, \"nzOpen\", void 0);\n\n  /**\n   * Use of this source code is governed by an MIT-style license that can be\n   * found in the LICENSE file at https://github.com/NG-ZORRO/ng-zorro-antd/blob/master/LICENSE\n   */\n  return NzSelectComponent;\n})();\nclass NzOptionItemGroupComponent {\n  constructor(elementRef) {\n    this.elementRef = elementRef;\n    this.nzLabel = null;\n    // TODO: move to host after View Engine deprecation\n    this.elementRef.nativeElement.classList.add('ant-select-item', 'ant-select-item-group');\n  }\n}\n/**\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://github.com/NG-ZORRO/ng-zorro-antd/blob/master/LICENSE\n */\nclass NzOptionItemComponent {\n  constructor(elementRef) {\n    this.elementRef = elementRef;\n    this.selected = false;\n    this.activated = false;\n    this.grouped = false;\n    this.customContent = false;\n    this.template = null;\n    this.disabled = false;\n    this.showState = false;\n    this.label = null;\n    this.value = null;\n    this.activatedValue = null;\n    this.listOfSelectedValue = [];\n    this.icon = null;\n    this.itemClick = new EventEmitter();\n    this.itemHover = new EventEmitter();\n    // TODO: move to host after View Engine deprecation\n    this.elementRef.nativeElement.classList.add('ant-select-item', 'ant-select-item-option');\n  }\n  onHostMouseEnter() {\n    if (!this.disabled) {\n      this.itemHover.next(this.value);\n    }\n  }\n  onHostClick() {\n    if (!this.disabled) {\n      this.itemClick.next(this.value);\n    }\n  }\n  ngOnChanges(changes) {\n    const {\n      value,\n      activatedValue,\n      listOfSelectedValue\n    } = changes;\n    if (value || listOfSelectedValue) {\n      this.selected = this.listOfSelectedValue.some(v => this.compareWith(v, this.value));\n    }\n    if (value || activatedValue) {\n      this.activated = this.compareWith(this.activatedValue, this.value);\n    }\n  }\n}\n/**\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://github.com/NG-ZORRO/ng-zorro-antd/blob/master/LICENSE\n */\nclass NzSelectArrowComponent {\n  constructor(elementRef) {\n    this.elementRef = elementRef;\n    this.loading = false;\n    this.search = false;\n    this.suffixIcon = null;\n    // TODO: move to host after View Engine deprecation\n    this.elementRef.nativeElement.classList.add('ant-select-arrow');\n  }\n}\n/**\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://github.com/NG-ZORRO/ng-zorro-antd/blob/master/LICENSE\n */\nclass NzSelectClearComponent {\n  constructor(elementRef) {\n    this.elementRef = elementRef;\n    this.clearIcon = null;\n    this.clear = new EventEmitter();\n    // TODO: move to host after View Engine deprecation\n    this.elementRef.nativeElement.classList.add('ant-select-clear');\n  }\n  onClick(e) {\n    e.preventDefault();\n    e.stopPropagation();\n    this.clear.emit(e);\n  }\n}\n/**\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://github.com/NG-ZORRO/ng-zorro-antd/blob/master/LICENSE\n */\nclass NzSelectItemComponent {\n  constructor(elementRef) {\n    this.elementRef = elementRef;\n    this.disabled = false;\n    this.label = null;\n    this.deletable = false;\n    this.removeIcon = null;\n    this.contentTemplateOutletContext = null;\n    this.contentTemplateOutlet = null;\n    this.delete = new EventEmitter();\n    // TODO: move to host after View Engine deprecation\n    this.elementRef.nativeElement.classList.add('ant-select-selection-item');\n  }\n  onDelete(e) {\n    e.preventDefault();\n    e.stopPropagation();\n    if (!this.disabled) {\n      this.delete.next(e);\n    }\n  }\n}\n/**\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://github.com/NG-ZORRO/ng-zorro-antd/blob/master/LICENSE\n */\nclass NzSelectPlaceholderComponent {\n  constructor(elementRef) {\n    this.elementRef = elementRef;\n    this.placeholder = null;\n    // TODO: move to host after View Engine deprecation\n    this.elementRef.nativeElement.classList.add('ant-select-selection-placeholder');\n  }\n}\n/**\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://github.com/NG-ZORRO/ng-zorro-antd/blob/master/LICENSE\n */\nclass NzSelectModule {}\n/**\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://github.com/NG-ZORRO/ng-zorro-antd/blob/master/LICENSE\n */\n\n/**\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://github.com/NG-ZORRO/ng-zorro-antd/blob/master/LICENSE\n */\n\n/**\n * Generated bundle index. Do not edit.\n */\n\nexport { NzOptionComponent, NzOptionContainerComponent, NzOptionGroupComponent, NzOptionItemComponent, NzOptionItemGroupComponent, NzSelectArrowComponent, NzSelectClearComponent, NzSelectComponent, NzSelectItemComponent, NzSelectModule, NzSelectPlaceholderComponent, NzSelectSearchComponent, NzSelectTopControlComponent, ɵ0 };\n//# sourceMappingURL=ng-zorro-antd-select.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}