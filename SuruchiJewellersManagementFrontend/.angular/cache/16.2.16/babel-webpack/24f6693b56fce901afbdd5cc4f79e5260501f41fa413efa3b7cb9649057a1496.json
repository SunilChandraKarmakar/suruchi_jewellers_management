{"ast":null,"code":"import { Directionality, BidiModule } from '@angular/cdk/bidi';\nimport { Platform, PlatformModule } from '@angular/cdk/platform';\nimport { CdkVirtualScrollViewport, ScrollingModule } from '@angular/cdk/scrolling';\nimport { CommonModule } from '@angular/common';\nimport { EventEmitter, Component, ChangeDetectionStrategy, ViewEncapsulation, ChangeDetectorRef, ElementRef, Input, Output, Directive, Renderer2, Injectable, Optional, ViewChild, NgZone, TemplateRef, ContentChild, ContentChildren, ViewChildren, NgModule } from '@angular/core';\nimport { FormsModule } from '@angular/forms';\nimport { NzButtonModule } from 'ng-zorro-antd/button';\nimport { NzCheckboxModule } from 'ng-zorro-antd/checkbox';\nimport { NzOutletModule } from 'ng-zorro-antd/core/outlet';\nimport { NzResizeObserver, NzResizeObserversModule } from 'ng-zorro-antd/core/resize-observers';\nimport { NzDropDownModule } from 'ng-zorro-antd/dropdown';\nimport { NzEmptyModule } from 'ng-zorro-antd/empty';\nimport { NzI18nService, NzI18nModule } from 'ng-zorro-antd/i18n';\nimport { NzIconModule } from 'ng-zorro-antd/icon';\nimport { NzMenuModule } from 'ng-zorro-antd/menu';\nimport { NzPaginationModule } from 'ng-zorro-antd/pagination';\nimport { NzRadioModule } from 'ng-zorro-antd/radio';\nimport { NzSpinModule } from 'ng-zorro-antd/spin';\nimport { arraysEqual, InputBoolean, isNil, measureScrollbar } from 'ng-zorro-antd/core/util';\nimport { Subject, ReplaySubject, BehaviorSubject, combineLatest, merge, fromEvent, EMPTY, of } from 'rxjs';\nimport { takeUntil, map, startWith, delay, switchMap, filter, distinctUntilChanged, debounceTime, skip, mergeMap } from 'rxjs/operators';\nimport { __decorate, __metadata } from 'tslib';\nimport { NzResizeService } from 'ng-zorro-antd/core/services';\nimport { NzConfigService, WithConfig } from 'ng-zorro-antd/core/config';\n\n/**\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://github.com/NG-ZORRO/ng-zorro-antd/blob/master/LICENSE\n */\nclass NzFilterTriggerComponent {\n  constructor(cdr, elementRef) {\n    this.cdr = cdr;\n    this.elementRef = elementRef;\n    this.nzActive = false;\n    this.nzVisible = false;\n    this.nzHasBackdrop = false;\n    this.nzVisibleChange = new EventEmitter();\n    // TODO: move to host after View Engine deprecation\n    this.elementRef.nativeElement.classList.add('ant-table-filter-trigger-container');\n  }\n  onVisibleChange(visible) {\n    this.nzVisible = visible;\n    this.nzVisibleChange.next(visible);\n  }\n  onFilterClick($event) {\n    $event.stopPropagation();\n  }\n  hide() {\n    this.nzVisible = false;\n    this.cdr.markForCheck();\n  }\n  show() {\n    this.nzVisible = true;\n    this.cdr.markForCheck();\n  }\n}\n/**\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://github.com/NG-ZORRO/ng-zorro-antd/blob/master/LICENSE\n */\nclass NzTableFilterComponent {\n  constructor(cdr, i18n, elementRef) {\n    this.cdr = cdr;\n    this.i18n = i18n;\n    this.elementRef = elementRef;\n    this.contentTemplate = null;\n    this.customFilter = false;\n    this.extraTemplate = null;\n    this.filterMultiple = true;\n    this.listOfFilter = [];\n    this.filterChange = new EventEmitter();\n    this.destroy$ = new Subject();\n    this.isChecked = false;\n    this.isVisible = false;\n    this.listOfParsedFilter = [];\n    this.listOfChecked = [];\n    // TODO: move to host after View Engine deprecation\n    this.elementRef.nativeElement.classList.add('ant-table-filter-column');\n  }\n  trackByValue(_, item) {\n    return item.value;\n  }\n  check(filter) {\n    if (this.filterMultiple) {\n      this.listOfParsedFilter = this.listOfParsedFilter.map(item => {\n        if (item === filter) {\n          return Object.assign(Object.assign({}, item), {\n            checked: !filter.checked\n          });\n        } else {\n          return item;\n        }\n      });\n      filter.checked = !filter.checked;\n    } else {\n      this.listOfParsedFilter = this.listOfParsedFilter.map(item => {\n        return Object.assign(Object.assign({}, item), {\n          checked: item === filter\n        });\n      });\n    }\n    this.isChecked = this.getCheckedStatus(this.listOfParsedFilter);\n  }\n  confirm() {\n    this.isVisible = false;\n    this.emitFilterData();\n  }\n  reset() {\n    this.isVisible = false;\n    this.listOfParsedFilter = this.parseListOfFilter(this.listOfFilter, true);\n    this.isChecked = this.getCheckedStatus(this.listOfParsedFilter);\n    this.emitFilterData();\n  }\n  onVisibleChange(value) {\n    this.isVisible = value;\n    if (!value) {\n      this.emitFilterData();\n    } else {\n      this.listOfChecked = this.listOfParsedFilter.filter(item => item.checked).map(item => item.value);\n    }\n  }\n  emitFilterData() {\n    const listOfChecked = this.listOfParsedFilter.filter(item => item.checked).map(item => item.value);\n    if (!arraysEqual(this.listOfChecked, listOfChecked)) {\n      if (this.filterMultiple) {\n        this.filterChange.emit(listOfChecked);\n      } else {\n        this.filterChange.emit(listOfChecked.length > 0 ? listOfChecked[0] : null);\n      }\n    }\n  }\n  parseListOfFilter(listOfFilter, reset) {\n    return listOfFilter.map(item => {\n      const checked = reset ? false : !!item.byDefault;\n      return {\n        text: item.text,\n        value: item.value,\n        checked\n      };\n    });\n  }\n  getCheckedStatus(listOfParsedFilter) {\n    return listOfParsedFilter.some(item => item.checked);\n  }\n  ngOnInit() {\n    this.i18n.localeChange.pipe(takeUntil(this.destroy$)).subscribe(() => {\n      this.locale = this.i18n.getLocaleData('Table');\n      this.cdr.markForCheck();\n    });\n  }\n  ngOnChanges(changes) {\n    const {\n      listOfFilter\n    } = changes;\n    if (listOfFilter && this.listOfFilter && this.listOfFilter.length) {\n      this.listOfParsedFilter = this.parseListOfFilter(this.listOfFilter);\n      this.isChecked = this.getCheckedStatus(this.listOfParsedFilter);\n    }\n  }\n  ngOnDestroy() {\n    this.destroy$.next();\n    this.destroy$.complete();\n  }\n}\n/**\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://github.com/NG-ZORRO/ng-zorro-antd/blob/master/LICENSE\n */\nclass NzRowExpandButtonDirective {\n  constructor(elementRef) {\n    this.elementRef = elementRef;\n    this.expand = false;\n    this.spaceMode = false;\n    this.expandChange = new EventEmitter();\n    // TODO: move to host after View Engine deprecation\n    this.elementRef.nativeElement.classList.add('ant-table-row-expand-icon');\n  }\n  onHostClick() {\n    if (!this.spaceMode) {\n      this.expand = !this.expand;\n      this.expandChange.next(this.expand);\n    }\n  }\n}\n/**\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://github.com/NG-ZORRO/ng-zorro-antd/blob/master/LICENSE\n */\nclass NzRowIndentDirective {\n  constructor(elementRef) {\n    this.elementRef = elementRef;\n    this.indentSize = 0;\n    // TODO: move to host after View Engine deprecation\n    this.elementRef.nativeElement.classList.add('ant-table-row-indent');\n  }\n}\n/**\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://github.com/NG-ZORRO/ng-zorro-antd/blob/master/LICENSE\n */\nclass NzTableSelectionComponent {\n  constructor(elementRef) {\n    this.elementRef = elementRef;\n    this.listOfSelections = [];\n    this.checked = false;\n    this.disabled = false;\n    this.indeterminate = false;\n    this.showCheckbox = false;\n    this.showRowSelection = false;\n    this.checkedChange = new EventEmitter();\n    // TODO: move to host after View Engine deprecation\n    this.elementRef.nativeElement.classList.add('ant-table-selection');\n  }\n  onCheckedChange(checked) {\n    this.checked = checked;\n    this.checkedChange.emit(checked);\n  }\n}\n/**\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://github.com/NG-ZORRO/ng-zorro-antd/blob/master/LICENSE\n */\nclass NzTableSortersComponent {\n  constructor(elementRef) {\n    this.elementRef = elementRef;\n    this.sortDirections = ['ascend', 'descend', null];\n    this.sortOrder = null;\n    this.contentTemplate = null;\n    this.isUp = false;\n    this.isDown = false;\n    // TODO: move to host after View Engine deprecation\n    this.elementRef.nativeElement.classList.add('ant-table-column-sorters');\n  }\n  ngOnChanges(changes) {\n    const {\n      sortDirections\n    } = changes;\n    if (sortDirections) {\n      this.isUp = this.sortDirections.indexOf('ascend') !== -1;\n      this.isDown = this.sortDirections.indexOf('descend') !== -1;\n    }\n  }\n}\n/**\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://github.com/NG-ZORRO/ng-zorro-antd/blob/master/LICENSE\n */\nclass NzCellFixedDirective {\n  constructor(renderer, elementRef) {\n    this.renderer = renderer;\n    this.elementRef = elementRef;\n    this.nzRight = false;\n    this.nzLeft = false;\n    this.colspan = null;\n    this.colSpan = null;\n    this.changes$ = new Subject();\n    this.isAutoLeft = false;\n    this.isAutoRight = false;\n    this.isFixedLeft = false;\n    this.isFixedRight = false;\n    this.isFixed = false;\n  }\n  setAutoLeftWidth(autoLeft) {\n    this.renderer.setStyle(this.elementRef.nativeElement, 'left', autoLeft);\n  }\n  setAutoRightWidth(autoRight) {\n    this.renderer.setStyle(this.elementRef.nativeElement, 'right', autoRight);\n  }\n  setIsFirstRight(isFirstRight) {\n    this.setFixClass(isFirstRight, 'ant-table-cell-fix-right-first');\n  }\n  setIsLastLeft(isLastLeft) {\n    this.setFixClass(isLastLeft, 'ant-table-cell-fix-left-last');\n  }\n  setFixClass(flag, className) {\n    // the setFixClass function may call many times, so remove it first.\n    this.renderer.removeClass(this.elementRef.nativeElement, className);\n    if (flag) {\n      this.renderer.addClass(this.elementRef.nativeElement, className);\n    }\n  }\n  ngOnChanges() {\n    this.setIsFirstRight(false);\n    this.setIsLastLeft(false);\n    this.isAutoLeft = this.nzLeft === '' || this.nzLeft === true;\n    this.isAutoRight = this.nzRight === '' || this.nzRight === true;\n    this.isFixedLeft = this.nzLeft !== false;\n    this.isFixedRight = this.nzRight !== false;\n    this.isFixed = this.isFixedLeft || this.isFixedRight;\n    const validatePx = value => {\n      if (typeof value === 'string' && value !== '') {\n        return value;\n      } else {\n        return null;\n      }\n    };\n    this.setAutoLeftWidth(validatePx(this.nzLeft));\n    this.setAutoRightWidth(validatePx(this.nzRight));\n    this.changes$.next();\n  }\n}\n/**\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://github.com/NG-ZORRO/ng-zorro-antd/blob/master/LICENSE\n */\nclass NzTableStyleService {\n  constructor() {\n    this.theadTemplate$ = new ReplaySubject(1);\n    this.hasFixLeft$ = new ReplaySubject(1);\n    this.hasFixRight$ = new ReplaySubject(1);\n    this.hostWidth$ = new ReplaySubject(1);\n    this.columnCount$ = new ReplaySubject(1);\n    this.showEmpty$ = new ReplaySubject(1);\n    this.noResult$ = new ReplaySubject(1);\n    this.listOfThWidthConfigPx$ = new BehaviorSubject([]);\n    this.tableWidthConfigPx$ = new BehaviorSubject([]);\n    this.manualWidthConfigPx$ = combineLatest([this.tableWidthConfigPx$, this.listOfThWidthConfigPx$]).pipe(map(([widthConfig, listOfWidth]) => widthConfig.length ? widthConfig : listOfWidth));\n    this.listOfAutoWidthPx$ = new ReplaySubject(1);\n    this.listOfListOfThWidthPx$ = merge( /** init with manual width **/\n    this.manualWidthConfigPx$, combineLatest([this.listOfAutoWidthPx$, this.manualWidthConfigPx$]).pipe(map(([autoWidth, manualWidth]) => {\n      /** use autoWidth until column length match **/\n      if (autoWidth.length === manualWidth.length) {\n        return autoWidth.map((width, index) => {\n          if (width === '0px') {\n            return manualWidth[index] || null;\n          } else {\n            return manualWidth[index] || width;\n          }\n        });\n      } else {\n        return manualWidth;\n      }\n    })));\n    this.listOfMeasureColumn$ = new ReplaySubject(1);\n    this.listOfListOfThWidth$ = this.listOfAutoWidthPx$.pipe(map(list => list.map(width => parseInt(width, 10))));\n    this.enableAutoMeasure$ = new ReplaySubject(1);\n  }\n  setTheadTemplate(template) {\n    this.theadTemplate$.next(template);\n  }\n  setHasFixLeft(hasFixLeft) {\n    this.hasFixLeft$.next(hasFixLeft);\n  }\n  setHasFixRight(hasFixRight) {\n    this.hasFixRight$.next(hasFixRight);\n  }\n  setTableWidthConfig(widthConfig) {\n    this.tableWidthConfigPx$.next(widthConfig);\n  }\n  setListOfTh(listOfTh) {\n    let columnCount = 0;\n    listOfTh.forEach(th => {\n      columnCount += th.colspan && +th.colspan || th.colSpan && +th.colSpan || 1;\n    });\n    const listOfThPx = listOfTh.map(item => item.nzWidth);\n    this.columnCount$.next(columnCount);\n    this.listOfThWidthConfigPx$.next(listOfThPx);\n  }\n  setListOfMeasureColumn(listOfTh) {\n    const listOfKeys = [];\n    listOfTh.forEach(th => {\n      const length = th.colspan && +th.colspan || th.colSpan && +th.colSpan || 1;\n      for (let i = 0; i < length; i++) {\n        listOfKeys.push(`measure_key_${i}`);\n      }\n    });\n    this.listOfMeasureColumn$.next(listOfKeys);\n  }\n  setListOfAutoWidth(listOfAutoWidth) {\n    this.listOfAutoWidthPx$.next(listOfAutoWidth.map(width => `${width}px`));\n  }\n  setShowEmpty(showEmpty) {\n    this.showEmpty$.next(showEmpty);\n  }\n  setNoResult(noResult) {\n    this.noResult$.next(noResult);\n  }\n  setScroll(scrollX, scrollY) {\n    const enableAutoMeasure = !!(scrollX || scrollY);\n    if (!enableAutoMeasure) {\n      this.setListOfAutoWidth([]);\n    }\n    this.enableAutoMeasure$.next(enableAutoMeasure);\n  }\n}\n/**\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://github.com/NG-ZORRO/ng-zorro-antd/blob/master/LICENSE\n */\nclass NzTableCellDirective {\n  constructor(nzTableStyleService) {\n    this.isInsideTable = false;\n    this.isInsideTable = !!nzTableStyleService;\n  }\n}\n/**\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://github.com/NG-ZORRO/ng-zorro-antd/blob/master/LICENSE\n */\nlet NzTdAddOnComponent = /*#__PURE__*/(() => {\n  class NzTdAddOnComponent {\n    constructor() {\n      this.nzChecked = false;\n      this.nzDisabled = false;\n      this.nzIndeterminate = false;\n      this.nzIndentSize = 0;\n      this.nzShowExpand = false;\n      this.nzShowCheckbox = false;\n      this.nzExpand = false;\n      this.nzCheckedChange = new EventEmitter();\n      this.nzExpandChange = new EventEmitter();\n      this.isNzShowExpandChanged = false;\n      this.isNzShowCheckboxChanged = false;\n    }\n    onCheckedChange(checked) {\n      this.nzChecked = checked;\n      this.nzCheckedChange.emit(checked);\n    }\n    onExpandChange(expand) {\n      this.nzExpand = expand;\n      this.nzExpandChange.emit(expand);\n    }\n    ngOnChanges(changes) {\n      const isFirstChange = value => value && value.firstChange && value.currentValue !== undefined;\n      const {\n        nzExpand,\n        nzChecked,\n        nzShowExpand,\n        nzShowCheckbox\n      } = changes;\n      if (nzShowExpand) {\n        this.isNzShowExpandChanged = true;\n      }\n      if (nzShowCheckbox) {\n        this.isNzShowCheckboxChanged = true;\n      }\n      if (isFirstChange(nzExpand) && !this.isNzShowExpandChanged) {\n        this.nzShowExpand = true;\n      }\n      if (isFirstChange(nzChecked) && !this.isNzShowCheckboxChanged) {\n        this.nzShowCheckbox = true;\n      }\n    }\n  }\n  __decorate([InputBoolean(), __metadata(\"design:type\", Object)], NzTdAddOnComponent.prototype, \"nzShowExpand\", void 0);\n  __decorate([InputBoolean(), __metadata(\"design:type\", Object)], NzTdAddOnComponent.prototype, \"nzShowCheckbox\", void 0);\n  __decorate([InputBoolean(), __metadata(\"design:type\", Object)], NzTdAddOnComponent.prototype, \"nzExpand\", void 0);\n  return NzTdAddOnComponent;\n})();\nlet NzThAddOnComponent = /*#__PURE__*/(() => {\n  class NzThAddOnComponent {\n    constructor(cdr) {\n      this.cdr = cdr;\n      this.manualClickOrder$ = new Subject();\n      this.calcOperatorChange$ = new Subject();\n      this.nzFilterValue = null;\n      this.sortOrder = null;\n      this.sortDirections = ['ascend', 'descend', null];\n      this.sortOrderChange$ = new Subject();\n      this.destroy$ = new Subject();\n      this.isNzShowSortChanged = false;\n      this.isNzShowFilterChanged = false;\n      this.nzFilterMultiple = true;\n      this.nzSortOrder = null;\n      this.nzSortPriority = false;\n      this.nzSortDirections = ['ascend', 'descend', null];\n      this.nzFilters = [];\n      this.nzSortFn = null;\n      this.nzFilterFn = null;\n      this.nzShowSort = false;\n      this.nzShowFilter = false;\n      this.nzCustomFilter = false;\n      this.nzCheckedChange = new EventEmitter();\n      this.nzSortOrderChange = new EventEmitter();\n      this.nzFilterChange = new EventEmitter();\n    }\n    getNextSortDirection(sortDirections, current) {\n      const index = sortDirections.indexOf(current);\n      if (index === sortDirections.length - 1) {\n        return sortDirections[0];\n      } else {\n        return sortDirections[index + 1];\n      }\n    }\n    emitNextSortValue() {\n      if (this.nzShowSort) {\n        const nextOrder = this.getNextSortDirection(this.sortDirections, this.sortOrder);\n        this.setSortOrder(nextOrder);\n        this.manualClickOrder$.next(this);\n      }\n    }\n    setSortOrder(order) {\n      this.sortOrderChange$.next(order);\n    }\n    clearSortOrder() {\n      if (this.sortOrder !== null) {\n        this.setSortOrder(null);\n      }\n    }\n    onFilterValueChange(value) {\n      this.nzFilterChange.emit(value);\n      this.nzFilterValue = value;\n      this.updateCalcOperator();\n    }\n    updateCalcOperator() {\n      this.calcOperatorChange$.next();\n    }\n    ngOnInit() {\n      this.sortOrderChange$.pipe(takeUntil(this.destroy$)).subscribe(order => {\n        if (this.sortOrder !== order) {\n          this.sortOrder = order;\n          this.nzSortOrderChange.emit(order);\n        }\n        this.updateCalcOperator();\n        this.cdr.markForCheck();\n      });\n    }\n    ngOnChanges(changes) {\n      const {\n        nzSortDirections,\n        nzFilters,\n        nzSortOrder,\n        nzSortFn,\n        nzFilterFn,\n        nzSortPriority,\n        nzFilterMultiple,\n        nzShowSort,\n        nzShowFilter\n      } = changes;\n      if (nzSortDirections) {\n        if (this.nzSortDirections && this.nzSortDirections.length) {\n          this.sortDirections = this.nzSortDirections;\n        }\n      }\n      if (nzSortOrder) {\n        this.sortOrder = this.nzSortOrder;\n        this.setSortOrder(this.nzSortOrder);\n      }\n      if (nzShowSort) {\n        this.isNzShowSortChanged = true;\n      }\n      if (nzShowFilter) {\n        this.isNzShowFilterChanged = true;\n      }\n      const isFirstChange = value => value && value.firstChange && value.currentValue !== undefined;\n      if ((isFirstChange(nzSortOrder) || isFirstChange(nzSortFn)) && !this.isNzShowSortChanged) {\n        this.nzShowSort = true;\n      }\n      if (isFirstChange(nzFilters) && !this.isNzShowFilterChanged) {\n        this.nzShowFilter = true;\n      }\n      if ((nzFilters || nzFilterMultiple) && this.nzShowFilter) {\n        const listOfValue = this.nzFilters.filter(item => item.byDefault).map(item => item.value);\n        this.nzFilterValue = this.nzFilterMultiple ? listOfValue : listOfValue[0] || null;\n      }\n      if (nzSortFn || nzFilterFn || nzSortPriority || nzFilters) {\n        this.updateCalcOperator();\n      }\n    }\n    ngOnDestroy() {\n      this.destroy$.next();\n      this.destroy$.complete();\n    }\n  }\n  __decorate([InputBoolean(), __metadata(\"design:type\", Object)], NzThAddOnComponent.prototype, \"nzShowSort\", void 0);\n  __decorate([InputBoolean(), __metadata(\"design:type\", Object)], NzThAddOnComponent.prototype, \"nzShowFilter\", void 0);\n  __decorate([InputBoolean(), __metadata(\"design:type\", Object)], NzThAddOnComponent.prototype, \"nzCustomFilter\", void 0);\n\n  /**\n   * Use of this source code is governed by an MIT-style license that can be\n   * found in the LICENSE file at https://github.com/NG-ZORRO/ng-zorro-antd/blob/master/LICENSE\n   */\n  return NzThAddOnComponent;\n})();\nclass NzThMeasureDirective {\n  constructor(renderer, elementRef) {\n    this.renderer = renderer;\n    this.elementRef = elementRef;\n    this.changes$ = new Subject();\n    this.nzWidth = null;\n    this.colspan = null;\n    this.colSpan = null;\n    this.rowspan = null;\n    this.rowSpan = null;\n  }\n  ngOnChanges(changes) {\n    const {\n      nzWidth,\n      colspan,\n      rowspan,\n      colSpan,\n      rowSpan\n    } = changes;\n    if (colspan || colSpan) {\n      const col = this.colspan || this.colSpan;\n      if (!isNil(col)) {\n        this.renderer.setAttribute(this.elementRef.nativeElement, 'colspan', `${col}`);\n      } else {\n        this.renderer.removeAttribute(this.elementRef.nativeElement, 'colspan');\n      }\n    }\n    if (rowspan || rowSpan) {\n      const row = this.rowspan || this.rowSpan;\n      if (!isNil(row)) {\n        this.renderer.setAttribute(this.elementRef.nativeElement, 'rowspan', `${row}`);\n      } else {\n        this.renderer.removeAttribute(this.elementRef.nativeElement, 'rowspan');\n      }\n    }\n    if (nzWidth || colspan) {\n      this.changes$.next();\n    }\n  }\n}\nlet NzThSelectionComponent = /*#__PURE__*/(() => {\n  class NzThSelectionComponent {\n    constructor(elementRef) {\n      this.elementRef = elementRef;\n      this.nzSelections = [];\n      this.nzChecked = false;\n      this.nzDisabled = false;\n      this.nzIndeterminate = false;\n      this.nzShowCheckbox = false;\n      this.nzShowRowSelection = false;\n      this.nzCheckedChange = new EventEmitter();\n      this.isNzShowExpandChanged = false;\n      this.isNzShowCheckboxChanged = false;\n      // TODO: move to host after View Engine deprecation\n      this.elementRef.nativeElement.classList.add('ant-table-selection-column');\n    }\n    onCheckedChange(checked) {\n      this.nzChecked = checked;\n      this.nzCheckedChange.emit(checked);\n    }\n    ngOnChanges(changes) {\n      const isFirstChange = value => value && value.firstChange && value.currentValue !== undefined;\n      const {\n        nzChecked,\n        nzSelections,\n        nzShowExpand,\n        nzShowCheckbox\n      } = changes;\n      if (nzShowExpand) {\n        this.isNzShowExpandChanged = true;\n      }\n      if (nzShowCheckbox) {\n        this.isNzShowCheckboxChanged = true;\n      }\n      if (isFirstChange(nzSelections) && !this.isNzShowExpandChanged) {\n        this.nzShowRowSelection = true;\n      }\n      if (isFirstChange(nzChecked) && !this.isNzShowCheckboxChanged) {\n        this.nzShowCheckbox = true;\n      }\n    }\n  }\n  __decorate([InputBoolean(), __metadata(\"design:type\", Object)], NzThSelectionComponent.prototype, \"nzShowCheckbox\", void 0);\n  __decorate([InputBoolean(), __metadata(\"design:type\", Object)], NzThSelectionComponent.prototype, \"nzShowRowSelection\", void 0);\n\n  /**\n   * Use of this source code is governed by an MIT-style license that can be\n   * found in the LICENSE file at https://github.com/NG-ZORRO/ng-zorro-antd/blob/master/LICENSE\n   */\n  return NzThSelectionComponent;\n})();\nclass NzCellAlignDirective {\n  constructor() {\n    this.nzAlign = null;\n  }\n}\n/**\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://github.com/NG-ZORRO/ng-zorro-antd/blob/master/LICENSE\n */\nlet NzCellEllipsisDirective = /*#__PURE__*/(() => {\n  class NzCellEllipsisDirective {\n    constructor() {\n      this.nzEllipsis = true;\n    }\n  }\n  __decorate([InputBoolean(), __metadata(\"design:type\", Object)], NzCellEllipsisDirective.prototype, \"nzEllipsis\", void 0);\n\n  /**\n   * Use of this source code is governed by an MIT-style license that can be\n   * found in the LICENSE file at https://github.com/NG-ZORRO/ng-zorro-antd/blob/master/LICENSE\n   */\n  return NzCellEllipsisDirective;\n})();\nlet NzCellBreakWordDirective = /*#__PURE__*/(() => {\n  class NzCellBreakWordDirective {\n    constructor() {\n      this.nzBreakWord = true;\n    }\n  }\n  __decorate([InputBoolean(), __metadata(\"design:type\", Object)], NzCellBreakWordDirective.prototype, \"nzBreakWord\", void 0);\n\n  /**\n   * Use of this source code is governed by an MIT-style license that can be\n   * found in the LICENSE file at https://github.com/NG-ZORRO/ng-zorro-antd/blob/master/LICENSE\n   */\n  return NzCellBreakWordDirective;\n})();\nclass NzTableContentComponent {\n  constructor() {\n    this.tableLayout = 'auto';\n    this.theadTemplate = null;\n    this.contentTemplate = null;\n    this.listOfColWidth = [];\n    this.scrollX = null;\n  }\n}\n/**\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://github.com/NG-ZORRO/ng-zorro-antd/blob/master/LICENSE\n */\nclass NzTableFixedRowComponent {\n  constructor(nzTableStyleService, renderer) {\n    this.nzTableStyleService = nzTableStyleService;\n    this.renderer = renderer;\n    this.hostWidth$ = new BehaviorSubject(null);\n    this.enableAutoMeasure$ = new BehaviorSubject(false);\n    this.destroy$ = new Subject();\n  }\n  ngOnInit() {\n    if (this.nzTableStyleService) {\n      const {\n        enableAutoMeasure$,\n        hostWidth$\n      } = this.nzTableStyleService;\n      enableAutoMeasure$.pipe(takeUntil(this.destroy$)).subscribe(this.enableAutoMeasure$);\n      hostWidth$.subscribe(this.hostWidth$);\n    }\n  }\n  ngAfterViewInit() {\n    this.nzTableStyleService.columnCount$.pipe(takeUntil(this.destroy$)).subscribe(count => {\n      this.renderer.setAttribute(this.tdElement.nativeElement, 'colspan', `${count}`);\n    });\n  }\n  ngOnDestroy() {\n    this.destroy$.next();\n    this.destroy$.complete();\n  }\n}\n/**\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://github.com/NG-ZORRO/ng-zorro-antd/blob/master/LICENSE\n */\nclass NzTableInnerDefaultComponent {\n  constructor(elementRef) {\n    this.elementRef = elementRef;\n    this.tableLayout = 'auto';\n    this.listOfColWidth = [];\n    this.theadTemplate = null;\n    this.contentTemplate = null;\n    // TODO: move to host after View Engine deprecation\n    this.elementRef.nativeElement.classList.add('ant-table-container');\n  }\n}\n/**\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://github.com/NG-ZORRO/ng-zorro-antd/blob/master/LICENSE\n */\nclass NzTableInnerScrollComponent {\n  constructor(renderer, ngZone, platform, resizeService, elementRef) {\n    this.renderer = renderer;\n    this.ngZone = ngZone;\n    this.platform = platform;\n    this.resizeService = resizeService;\n    this.elementRef = elementRef;\n    this.data = [];\n    this.scrollX = null;\n    this.scrollY = null;\n    this.contentTemplate = null;\n    this.widthConfig = [];\n    this.listOfColWidth = [];\n    this.theadTemplate = null;\n    this.virtualTemplate = null;\n    this.virtualItemSize = 0;\n    this.virtualMaxBufferPx = 200;\n    this.virtualMinBufferPx = 100;\n    this.virtualForTrackBy = index => index;\n    this.headerStyleMap = {};\n    this.bodyStyleMap = {};\n    this.verticalScrollBarWidth = 0;\n    this.noDateVirtualHeight = '182px';\n    this.data$ = new Subject();\n    this.scroll$ = new Subject();\n    this.destroy$ = new Subject();\n    // TODO: move to host after View Engine deprecation\n    this.elementRef.nativeElement.classList.add('ant-table-container');\n  }\n  setScrollPositionClassName(clear = false) {\n    const {\n      scrollWidth,\n      scrollLeft,\n      clientWidth\n    } = this.tableBodyElement.nativeElement;\n    const leftClassName = 'ant-table-ping-left';\n    const rightClassName = 'ant-table-ping-right';\n    if (scrollWidth === clientWidth && scrollWidth !== 0 || clear) {\n      this.renderer.removeClass(this.tableMainElement, leftClassName);\n      this.renderer.removeClass(this.tableMainElement, rightClassName);\n    } else if (scrollLeft === 0) {\n      this.renderer.removeClass(this.tableMainElement, leftClassName);\n      this.renderer.addClass(this.tableMainElement, rightClassName);\n    } else if (scrollWidth === scrollLeft + clientWidth) {\n      this.renderer.removeClass(this.tableMainElement, rightClassName);\n      this.renderer.addClass(this.tableMainElement, leftClassName);\n    } else {\n      this.renderer.addClass(this.tableMainElement, leftClassName);\n      this.renderer.addClass(this.tableMainElement, rightClassName);\n    }\n  }\n  ngOnChanges(changes) {\n    const {\n      scrollX,\n      scrollY,\n      data\n    } = changes;\n    if (scrollX || scrollY) {\n      const hasVerticalScrollBar = this.verticalScrollBarWidth !== 0;\n      this.headerStyleMap = {\n        overflowX: 'hidden',\n        overflowY: this.scrollY && hasVerticalScrollBar ? 'scroll' : 'hidden'\n      };\n      this.bodyStyleMap = {\n        overflowY: this.scrollY ? 'scroll' : 'hidden',\n        overflowX: this.scrollX ? 'auto' : null,\n        maxHeight: this.scrollY\n      };\n      this.scroll$.next();\n    }\n    if (data) {\n      this.data$.next();\n    }\n  }\n  ngAfterViewInit() {\n    if (this.platform.isBrowser) {\n      this.ngZone.runOutsideAngular(() => {\n        const scrollEvent$ = this.scroll$.pipe(startWith(null), delay(0), switchMap(() => fromEvent(this.tableBodyElement.nativeElement, 'scroll').pipe(startWith(true))), takeUntil(this.destroy$));\n        const resize$ = this.resizeService.subscribe().pipe(takeUntil(this.destroy$));\n        const data$ = this.data$.pipe(takeUntil(this.destroy$));\n        const setClassName$ = merge(scrollEvent$, resize$, data$, this.scroll$).pipe(startWith(true), delay(0), takeUntil(this.destroy$));\n        setClassName$.subscribe(() => this.setScrollPositionClassName());\n        scrollEvent$.pipe(filter(() => !!this.scrollY)).subscribe(() => this.tableHeaderElement.nativeElement.scrollLeft = this.tableBodyElement.nativeElement.scrollLeft);\n      });\n    }\n  }\n  ngOnDestroy() {\n    this.setScrollPositionClassName(true);\n    this.destroy$.next();\n    this.destroy$.complete();\n  }\n}\n/**\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://github.com/NG-ZORRO/ng-zorro-antd/blob/master/LICENSE\n */\nclass NzTableVirtualScrollDirective {\n  constructor(templateRef) {\n    this.templateRef = templateRef;\n  }\n}\n/**\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://github.com/NG-ZORRO/ng-zorro-antd/blob/master/LICENSE\n */\nclass NzTableDataService {\n  constructor() {\n    this.destroy$ = new Subject();\n    this.pageIndex$ = new BehaviorSubject(1);\n    this.frontPagination$ = new BehaviorSubject(true);\n    this.pageSize$ = new BehaviorSubject(10);\n    this.listOfData$ = new BehaviorSubject([]);\n    this.pageIndexDistinct$ = this.pageIndex$.pipe(distinctUntilChanged());\n    this.pageSizeDistinct$ = this.pageSize$.pipe(distinctUntilChanged());\n    this.listOfCalcOperator$ = new BehaviorSubject([]);\n    this.queryParams$ = combineLatest([this.pageIndexDistinct$, this.pageSizeDistinct$, this.listOfCalcOperator$]).pipe(debounceTime(0), skip(1), map(([pageIndex, pageSize, listOfCalc]) => {\n      return {\n        pageIndex,\n        pageSize,\n        sort: listOfCalc.filter(item => item.sortFn).map(item => {\n          return {\n            key: item.key,\n            value: item.sortOrder\n          };\n        }),\n        filter: listOfCalc.filter(item => item.filterFn).map(item => {\n          return {\n            key: item.key,\n            value: item.filterValue\n          };\n        })\n      };\n    }));\n    this.listOfDataAfterCalc$ = combineLatest([this.listOfData$, this.listOfCalcOperator$]).pipe(map(([listOfData, listOfCalcOperator]) => {\n      let listOfDataAfterCalc = [...listOfData];\n      const listOfFilterOperator = listOfCalcOperator.filter(item => {\n        const {\n          filterValue,\n          filterFn\n        } = item;\n        const isReset = filterValue === null || filterValue === undefined || Array.isArray(filterValue) && filterValue.length === 0;\n        return !isReset && typeof filterFn === 'function';\n      });\n      for (const item of listOfFilterOperator) {\n        const {\n          filterFn,\n          filterValue\n        } = item;\n        listOfDataAfterCalc = listOfDataAfterCalc.filter(data => filterFn(filterValue, data));\n      }\n      const listOfSortOperator = listOfCalcOperator.filter(item => item.sortOrder !== null && typeof item.sortFn === 'function').sort((a, b) => +b.sortPriority - +a.sortPriority);\n      if (listOfCalcOperator.length) {\n        listOfDataAfterCalc.sort((record1, record2) => {\n          for (const item of listOfSortOperator) {\n            const {\n              sortFn,\n              sortOrder\n            } = item;\n            if (sortFn && sortOrder) {\n              const compareResult = sortFn(record1, record2, sortOrder);\n              if (compareResult !== 0) {\n                return sortOrder === 'ascend' ? compareResult : -compareResult;\n              }\n            }\n          }\n          return 0;\n        });\n      }\n      return listOfDataAfterCalc;\n    }));\n    this.listOfFrontEndCurrentPageData$ = combineLatest([this.pageIndexDistinct$, this.pageSizeDistinct$, this.listOfDataAfterCalc$]).pipe(takeUntil(this.destroy$), filter(value => {\n      const [pageIndex, pageSize, listOfData] = value;\n      const maxPageIndex = Math.ceil(listOfData.length / pageSize) || 1;\n      return pageIndex <= maxPageIndex;\n    }), map(([pageIndex, pageSize, listOfData]) => {\n      return listOfData.slice((pageIndex - 1) * pageSize, pageIndex * pageSize);\n    }));\n    this.listOfCurrentPageData$ = this.frontPagination$.pipe(switchMap(pagination => pagination ? this.listOfFrontEndCurrentPageData$ : this.listOfDataAfterCalc$));\n    this.total$ = this.frontPagination$.pipe(switchMap(pagination => pagination ? this.listOfDataAfterCalc$ : this.listOfData$), map(list => list.length), distinctUntilChanged());\n  }\n  updatePageSize(size) {\n    this.pageSize$.next(size);\n  }\n  updateFrontPagination(pagination) {\n    this.frontPagination$.next(pagination);\n  }\n  updatePageIndex(index) {\n    this.pageIndex$.next(index);\n  }\n  updateListOfData(list) {\n    this.listOfData$.next(list);\n  }\n  ngOnDestroy() {\n    this.destroy$.next();\n    this.destroy$.complete();\n  }\n}\n/**\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://github.com/NG-ZORRO/ng-zorro-antd/blob/master/LICENSE\n */\nconst NZ_CONFIG_MODULE_NAME = 'table';\nlet NzTableComponent = /*#__PURE__*/(() => {\n  class NzTableComponent {\n    constructor(elementRef, nzResizeObserver, nzConfigService, cdr, nzTableStyleService, nzTableDataService, directionality) {\n      this.elementRef = elementRef;\n      this.nzResizeObserver = nzResizeObserver;\n      this.nzConfigService = nzConfigService;\n      this.cdr = cdr;\n      this.nzTableStyleService = nzTableStyleService;\n      this.nzTableDataService = nzTableDataService;\n      this.directionality = directionality;\n      this._nzModuleName = NZ_CONFIG_MODULE_NAME;\n      this.nzTableLayout = 'auto';\n      this.nzShowTotal = null;\n      this.nzItemRender = null;\n      this.nzTitle = null;\n      this.nzFooter = null;\n      this.nzNoResult = undefined;\n      this.nzPageSizeOptions = [10, 20, 30, 40, 50];\n      this.nzVirtualItemSize = 0;\n      this.nzVirtualMaxBufferPx = 200;\n      this.nzVirtualMinBufferPx = 100;\n      this.nzVirtualForTrackBy = index => index;\n      this.nzLoadingDelay = 0;\n      this.nzPageIndex = 1;\n      this.nzPageSize = 10;\n      this.nzTotal = 0;\n      this.nzWidthConfig = [];\n      this.nzData = [];\n      this.nzPaginationPosition = 'bottom';\n      this.nzScroll = {\n        x: null,\n        y: null\n      };\n      this.nzPaginationType = 'default';\n      this.nzFrontPagination = true;\n      this.nzTemplateMode = false;\n      this.nzShowPagination = true;\n      this.nzLoading = false;\n      this.nzOuterBordered = false;\n      this.nzLoadingIndicator = null;\n      this.nzBordered = false;\n      this.nzSize = 'default';\n      this.nzShowSizeChanger = false;\n      this.nzHideOnSinglePage = false;\n      this.nzShowQuickJumper = false;\n      this.nzSimple = false;\n      this.nzPageSizeChange = new EventEmitter();\n      this.nzPageIndexChange = new EventEmitter();\n      this.nzQueryParams = new EventEmitter();\n      this.nzCurrentPageDataChange = new EventEmitter();\n      /** public data for ngFor tr */\n      this.data = [];\n      this.scrollX = null;\n      this.scrollY = null;\n      this.theadTemplate = null;\n      this.listOfAutoColWidth = [];\n      this.listOfManualColWidth = [];\n      this.hasFixLeft = false;\n      this.hasFixRight = false;\n      this.showPagination = true;\n      this.destroy$ = new Subject();\n      this.loading$ = new BehaviorSubject(false);\n      this.templateMode$ = new BehaviorSubject(false);\n      this.dir = 'ltr';\n      this.verticalScrollBarWidth = 0;\n      // TODO: move to host after View Engine deprecation\n      this.elementRef.nativeElement.classList.add('ant-table-wrapper');\n      this.nzConfigService.getConfigChangeEventForComponent(NZ_CONFIG_MODULE_NAME).pipe(takeUntil(this.destroy$)).subscribe(() => {\n        this.cdr.markForCheck();\n      });\n    }\n    onPageSizeChange(size) {\n      this.nzTableDataService.updatePageSize(size);\n    }\n    onPageIndexChange(index) {\n      this.nzTableDataService.updatePageIndex(index);\n    }\n    ngOnInit() {\n      var _a;\n      const {\n        pageIndexDistinct$,\n        pageSizeDistinct$,\n        listOfCurrentPageData$,\n        total$,\n        queryParams$\n      } = this.nzTableDataService;\n      const {\n        theadTemplate$,\n        hasFixLeft$,\n        hasFixRight$\n      } = this.nzTableStyleService;\n      this.dir = this.directionality.value;\n      (_a = this.directionality.change) === null || _a === void 0 ? void 0 : _a.pipe(takeUntil(this.destroy$)).subscribe(direction => {\n        this.dir = direction;\n        this.cdr.detectChanges();\n      });\n      queryParams$.pipe(takeUntil(this.destroy$)).subscribe(this.nzQueryParams);\n      pageIndexDistinct$.pipe(takeUntil(this.destroy$)).subscribe(pageIndex => {\n        if (pageIndex !== this.nzPageIndex) {\n          this.nzPageIndex = pageIndex;\n          this.nzPageIndexChange.next(pageIndex);\n        }\n      });\n      pageSizeDistinct$.pipe(takeUntil(this.destroy$)).subscribe(pageSize => {\n        if (pageSize !== this.nzPageSize) {\n          this.nzPageSize = pageSize;\n          this.nzPageSizeChange.next(pageSize);\n        }\n      });\n      total$.pipe(takeUntil(this.destroy$), filter(() => this.nzFrontPagination)).subscribe(total => {\n        if (total !== this.nzTotal) {\n          this.nzTotal = total;\n          this.cdr.markForCheck();\n        }\n      });\n      listOfCurrentPageData$.pipe(takeUntil(this.destroy$)).subscribe(data => {\n        this.data = data;\n        this.nzCurrentPageDataChange.next(data);\n        this.cdr.markForCheck();\n      });\n      theadTemplate$.pipe(takeUntil(this.destroy$)).subscribe(theadTemplate => {\n        this.theadTemplate = theadTemplate;\n        this.cdr.markForCheck();\n      });\n      hasFixLeft$.pipe(takeUntil(this.destroy$)).subscribe(hasFixLeft => {\n        this.hasFixLeft = hasFixLeft;\n        this.cdr.markForCheck();\n      });\n      hasFixRight$.pipe(takeUntil(this.destroy$)).subscribe(hasFixRight => {\n        this.hasFixRight = hasFixRight;\n        this.cdr.markForCheck();\n      });\n      combineLatest([total$, this.loading$, this.templateMode$]).pipe(map(([total, loading, templateMode]) => total === 0 && !loading && !templateMode), takeUntil(this.destroy$)).subscribe(empty => {\n        this.nzTableStyleService.setShowEmpty(empty);\n      });\n      this.verticalScrollBarWidth = measureScrollbar('vertical');\n      this.nzTableStyleService.listOfListOfThWidthPx$.pipe(takeUntil(this.destroy$)).subscribe(listOfWidth => {\n        this.listOfAutoColWidth = listOfWidth;\n        this.cdr.markForCheck();\n      });\n      this.nzTableStyleService.manualWidthConfigPx$.pipe(takeUntil(this.destroy$)).subscribe(listOfWidth => {\n        this.listOfManualColWidth = listOfWidth;\n        this.cdr.markForCheck();\n      });\n    }\n    ngOnChanges(changes) {\n      const {\n        nzScroll,\n        nzPageIndex,\n        nzPageSize,\n        nzFrontPagination,\n        nzData,\n        nzWidthConfig,\n        nzNoResult,\n        nzLoading,\n        nzTemplateMode\n      } = changes;\n      if (nzPageIndex) {\n        this.nzTableDataService.updatePageIndex(this.nzPageIndex);\n      }\n      if (nzPageSize) {\n        this.nzTableDataService.updatePageSize(this.nzPageSize);\n      }\n      if (nzData) {\n        this.nzData = this.nzData || [];\n        this.nzTableDataService.updateListOfData(this.nzData);\n      }\n      if (nzFrontPagination) {\n        this.nzTableDataService.updateFrontPagination(this.nzFrontPagination);\n      }\n      if (nzScroll) {\n        this.setScrollOnChanges();\n      }\n      if (nzWidthConfig) {\n        this.nzTableStyleService.setTableWidthConfig(this.nzWidthConfig);\n      }\n      if (nzLoading) {\n        this.loading$.next(this.nzLoading);\n      }\n      if (nzTemplateMode) {\n        this.templateMode$.next(this.nzTemplateMode);\n      }\n      if (nzNoResult) {\n        this.nzTableStyleService.setNoResult(this.nzNoResult);\n      }\n      this.updateShowPagination();\n    }\n    ngAfterViewInit() {\n      this.nzResizeObserver.observe(this.elementRef).pipe(map(([entry]) => {\n        const {\n          width\n        } = entry.target.getBoundingClientRect();\n        const scrollBarWidth = this.scrollY ? this.verticalScrollBarWidth : 0;\n        return Math.floor(width - scrollBarWidth);\n      }), takeUntil(this.destroy$)).subscribe(this.nzTableStyleService.hostWidth$);\n      if (this.nzTableInnerScrollComponent && this.nzTableInnerScrollComponent.cdkVirtualScrollViewport) {\n        this.cdkVirtualScrollViewport = this.nzTableInnerScrollComponent.cdkVirtualScrollViewport;\n      }\n    }\n    ngOnDestroy() {\n      this.destroy$.next();\n      this.destroy$.complete();\n    }\n    setScrollOnChanges() {\n      this.scrollX = this.nzScroll && this.nzScroll.x || null;\n      this.scrollY = this.nzScroll && this.nzScroll.y || null;\n      this.nzTableStyleService.setScroll(this.scrollX, this.scrollY);\n    }\n    updateShowPagination() {\n      this.showPagination = this.nzHideOnSinglePage && this.nzData.length > this.nzPageSize || this.nzData.length > 0 && !this.nzHideOnSinglePage || !this.nzFrontPagination && this.nzTotal > this.nzPageSize;\n    }\n  }\n  __decorate([InputBoolean(), __metadata(\"design:type\", Object)], NzTableComponent.prototype, \"nzFrontPagination\", void 0);\n  __decorate([InputBoolean(), __metadata(\"design:type\", Object)], NzTableComponent.prototype, \"nzTemplateMode\", void 0);\n  __decorate([InputBoolean(), __metadata(\"design:type\", Object)], NzTableComponent.prototype, \"nzShowPagination\", void 0);\n  __decorate([InputBoolean(), __metadata(\"design:type\", Object)], NzTableComponent.prototype, \"nzLoading\", void 0);\n  __decorate([InputBoolean(), __metadata(\"design:type\", Object)], NzTableComponent.prototype, \"nzOuterBordered\", void 0);\n  __decorate([WithConfig(), __metadata(\"design:type\", Object)], NzTableComponent.prototype, \"nzLoadingIndicator\", void 0);\n  __decorate([WithConfig(), InputBoolean(), __metadata(\"design:type\", Boolean)], NzTableComponent.prototype, \"nzBordered\", void 0);\n  __decorate([WithConfig(), __metadata(\"design:type\", String)], NzTableComponent.prototype, \"nzSize\", void 0);\n  __decorate([WithConfig(), InputBoolean(), __metadata(\"design:type\", Boolean)], NzTableComponent.prototype, \"nzShowSizeChanger\", void 0);\n  __decorate([WithConfig(), InputBoolean(), __metadata(\"design:type\", Boolean)], NzTableComponent.prototype, \"nzHideOnSinglePage\", void 0);\n  __decorate([WithConfig(), InputBoolean(), __metadata(\"design:type\", Boolean)], NzTableComponent.prototype, \"nzShowQuickJumper\", void 0);\n  __decorate([WithConfig(), InputBoolean(), __metadata(\"design:type\", Boolean)], NzTableComponent.prototype, \"nzSimple\", void 0);\n\n  /**\n   * Use of this source code is governed by an MIT-style license that can be\n   * found in the LICENSE file at https://github.com/NG-ZORRO/ng-zorro-antd/blob/master/LICENSE\n   */\n  return NzTableComponent;\n})();\nclass NzTbodyComponent {\n  constructor(nzTableStyleService) {\n    this.nzTableStyleService = nzTableStyleService;\n    this.isInsideTable = false;\n    this.showEmpty$ = new BehaviorSubject(false);\n    this.noResult$ = new BehaviorSubject(undefined);\n    this.listOfMeasureColumn$ = new BehaviorSubject([]);\n    this.destroy$ = new Subject();\n    this.isInsideTable = !!this.nzTableStyleService;\n    if (this.nzTableStyleService) {\n      const {\n        showEmpty$,\n        noResult$,\n        listOfMeasureColumn$\n      } = this.nzTableStyleService;\n      noResult$.pipe(takeUntil(this.destroy$)).subscribe(this.noResult$);\n      listOfMeasureColumn$.pipe(takeUntil(this.destroy$)).subscribe(this.listOfMeasureColumn$);\n      showEmpty$.pipe(takeUntil(this.destroy$)).subscribe(this.showEmpty$);\n    }\n  }\n  onListOfAutoWidthChange(listOfAutoWidth) {\n    this.nzTableStyleService.setListOfAutoWidth(listOfAutoWidth);\n  }\n  ngOnDestroy() {\n    this.destroy$.next();\n    this.destroy$.complete();\n  }\n}\n/**\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://github.com/NG-ZORRO/ng-zorro-antd/blob/master/LICENSE\n */\nclass NzTrDirective {\n  constructor(nzTableStyleService) {\n    this.nzTableStyleService = nzTableStyleService;\n    this.destroy$ = new Subject();\n    this.listOfFixedColumns$ = new ReplaySubject(1);\n    this.listOfColumns$ = new ReplaySubject(1);\n    this.listOfFixedColumnsChanges$ = this.listOfFixedColumns$.pipe(switchMap(list => merge(...[this.listOfFixedColumns$, ...list.map(c => c.changes$)]).pipe(mergeMap(() => this.listOfFixedColumns$))), takeUntil(this.destroy$));\n    this.listOfFixedLeftColumnChanges$ = this.listOfFixedColumnsChanges$.pipe(map(list => list.filter(item => item.nzLeft !== false)));\n    this.listOfFixedRightColumnChanges$ = this.listOfFixedColumnsChanges$.pipe(map(list => list.filter(item => item.nzRight !== false)));\n    this.listOfColumnsChanges$ = this.listOfColumns$.pipe(switchMap(list => merge(...[this.listOfColumns$, ...list.map(c => c.changes$)]).pipe(mergeMap(() => this.listOfColumns$))), takeUntil(this.destroy$));\n    this.isInsideTable = false;\n    this.isInsideTable = !!nzTableStyleService;\n  }\n  ngAfterContentInit() {\n    if (this.nzTableStyleService) {\n      this.listOfCellFixedDirective.changes.pipe(startWith(this.listOfCellFixedDirective), takeUntil(this.destroy$)).subscribe(this.listOfFixedColumns$);\n      this.listOfNzThDirective.changes.pipe(startWith(this.listOfNzThDirective), takeUntil(this.destroy$)).subscribe(this.listOfColumns$);\n      /** set last left and first right **/\n      this.listOfFixedLeftColumnChanges$.subscribe(listOfFixedLeft => {\n        listOfFixedLeft.forEach(cell => cell.setIsLastLeft(cell === listOfFixedLeft[listOfFixedLeft.length - 1]));\n      });\n      this.listOfFixedRightColumnChanges$.subscribe(listOfFixedRight => {\n        listOfFixedRight.forEach(cell => cell.setIsFirstRight(cell === listOfFixedRight[0]));\n      });\n      /** calculate fixed nzLeft and nzRight **/\n      combineLatest([this.nzTableStyleService.listOfListOfThWidth$, this.listOfFixedLeftColumnChanges$]).pipe(takeUntil(this.destroy$)).subscribe(([listOfAutoWidth, listOfLeftCell]) => {\n        listOfLeftCell.forEach((cell, index) => {\n          if (cell.isAutoLeft) {\n            const currentArray = listOfLeftCell.slice(0, index);\n            const count = currentArray.reduce((pre, cur) => pre + (cur.colspan || cur.colSpan || 1), 0);\n            const width = listOfAutoWidth.slice(0, count).reduce((pre, cur) => pre + cur, 0);\n            cell.setAutoLeftWidth(`${width}px`);\n          }\n        });\n      });\n      combineLatest([this.nzTableStyleService.listOfListOfThWidth$, this.listOfFixedRightColumnChanges$]).pipe(takeUntil(this.destroy$)).subscribe(([listOfAutoWidth, listOfRightCell]) => {\n        listOfRightCell.forEach((_, index) => {\n          const cell = listOfRightCell[listOfRightCell.length - index - 1];\n          if (cell.isAutoRight) {\n            const currentArray = listOfRightCell.slice(listOfRightCell.length - index, listOfRightCell.length);\n            const count = currentArray.reduce((pre, cur) => pre + (cur.colspan || cur.colSpan || 1), 0);\n            const width = listOfAutoWidth.slice(listOfAutoWidth.length - count, listOfAutoWidth.length).reduce((pre, cur) => pre + cur, 0);\n            cell.setAutoRightWidth(`${width}px`);\n          }\n        });\n      });\n    }\n  }\n  ngOnDestroy() {\n    this.destroy$.next();\n    this.destroy$.complete();\n  }\n}\n/**\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://github.com/NG-ZORRO/ng-zorro-antd/blob/master/LICENSE\n */\nclass NzTheadComponent {\n  constructor(elementRef, renderer, nzTableStyleService, nzTableDataService) {\n    this.elementRef = elementRef;\n    this.renderer = renderer;\n    this.nzTableStyleService = nzTableStyleService;\n    this.nzTableDataService = nzTableDataService;\n    this.destroy$ = new Subject();\n    this.isInsideTable = false;\n    this.nzSortOrderChange = new EventEmitter();\n    this.isInsideTable = !!this.nzTableStyleService;\n  }\n  ngOnInit() {\n    if (this.nzTableStyleService) {\n      this.nzTableStyleService.setTheadTemplate(this.templateRef);\n    }\n  }\n  ngAfterContentInit() {\n    if (this.nzTableStyleService) {\n      const firstTableRow$ = this.listOfNzTrDirective.changes.pipe(startWith(this.listOfNzTrDirective), map(item => item && item.first));\n      const listOfColumnsChanges$ = firstTableRow$.pipe(switchMap(firstTableRow => firstTableRow ? firstTableRow.listOfColumnsChanges$ : EMPTY), takeUntil(this.destroy$));\n      listOfColumnsChanges$.subscribe(data => this.nzTableStyleService.setListOfTh(data));\n      /** TODO: need reset the measure row when scrollX change **/\n      this.nzTableStyleService.enableAutoMeasure$.pipe(switchMap(enable => enable ? listOfColumnsChanges$ : of([]))).pipe(takeUntil(this.destroy$)).subscribe(data => this.nzTableStyleService.setListOfMeasureColumn(data));\n      const listOfFixedLeftColumnChanges$ = firstTableRow$.pipe(switchMap(firstTr => firstTr ? firstTr.listOfFixedLeftColumnChanges$ : EMPTY), takeUntil(this.destroy$));\n      const listOfFixedRightColumnChanges$ = firstTableRow$.pipe(switchMap(firstTr => firstTr ? firstTr.listOfFixedRightColumnChanges$ : EMPTY), takeUntil(this.destroy$));\n      listOfFixedLeftColumnChanges$.subscribe(listOfFixedLeftColumn => {\n        this.nzTableStyleService.setHasFixLeft(listOfFixedLeftColumn.length !== 0);\n      });\n      listOfFixedRightColumnChanges$.subscribe(listOfFixedRightColumn => {\n        this.nzTableStyleService.setHasFixRight(listOfFixedRightColumn.length !== 0);\n      });\n    }\n    if (this.nzTableDataService) {\n      const listOfColumn$ = this.listOfNzThAddOnComponent.changes.pipe(startWith(this.listOfNzThAddOnComponent));\n      const manualSort$ = listOfColumn$.pipe(switchMap(() => merge(...this.listOfNzThAddOnComponent.map(th => th.manualClickOrder$))), takeUntil(this.destroy$));\n      manualSort$.subscribe(data => {\n        const emitValue = {\n          key: data.nzColumnKey,\n          value: data.sortOrder\n        };\n        this.nzSortOrderChange.emit(emitValue);\n        if (data.nzSortFn && data.nzSortPriority === false) {\n          this.listOfNzThAddOnComponent.filter(th => th !== data).forEach(th => th.clearSortOrder());\n        }\n      });\n      const listOfCalcOperator$ = listOfColumn$.pipe(switchMap(list => merge(...[listOfColumn$, ...list.map(c => c.calcOperatorChange$)]).pipe(mergeMap(() => listOfColumn$))), map(list => list.filter(item => !!item.nzSortFn || !!item.nzFilterFn).map(item => {\n        const {\n          nzSortFn,\n          sortOrder,\n          nzFilterFn,\n          nzFilterValue,\n          nzSortPriority,\n          nzColumnKey\n        } = item;\n        return {\n          key: nzColumnKey,\n          sortFn: nzSortFn,\n          sortPriority: nzSortPriority,\n          sortOrder: sortOrder,\n          filterFn: nzFilterFn,\n          filterValue: nzFilterValue\n        };\n      })),\n      // TODO: after checked error here\n      delay(0), takeUntil(this.destroy$));\n      listOfCalcOperator$.subscribe(list => {\n        this.nzTableDataService.listOfCalcOperator$.next(list);\n      });\n    }\n  }\n  ngAfterViewInit() {\n    if (this.nzTableStyleService) {\n      this.renderer.removeChild(this.renderer.parentNode(this.elementRef.nativeElement), this.elementRef.nativeElement);\n    }\n  }\n  ngOnDestroy() {\n    this.destroy$.next();\n    this.destroy$.complete();\n  }\n}\n/**\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://github.com/NG-ZORRO/ng-zorro-antd/blob/master/LICENSE\n */\nclass NzTableTitleFooterComponent {\n  constructor() {\n    this.title = null;\n    this.footer = null;\n  }\n}\n/**\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://github.com/NG-ZORRO/ng-zorro-antd/blob/master/LICENSE\n */\nclass NzTrExpandDirective {\n  constructor(elementRef) {\n    this.elementRef = elementRef;\n    this.nzExpand = true;\n    // TODO: move to host after View Engine deprecation\n    this.elementRef.nativeElement.classList.add('ant-table-expanded-row');\n  }\n}\n/**\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://github.com/NG-ZORRO/ng-zorro-antd/blob/master/LICENSE\n */\nclass NzTrMeasureComponent {\n  constructor(nzResizeObserver, ngZone, elementRef) {\n    this.nzResizeObserver = nzResizeObserver;\n    this.ngZone = ngZone;\n    this.elementRef = elementRef;\n    this.listOfMeasureColumn = [];\n    this.listOfAutoWidth = new EventEmitter();\n    this.destroy$ = new Subject();\n    // TODO: move to host after View Engine deprecation\n    this.elementRef.nativeElement.classList.add('ant-table-measure-now');\n  }\n  trackByFunc(_, key) {\n    return key;\n  }\n  ngAfterViewInit() {\n    this.listOfTdElement.changes.pipe(startWith(this.listOfTdElement)).pipe(switchMap(list => {\n      return combineLatest(list.toArray().map(item => {\n        return this.nzResizeObserver.observe(item).pipe(map(([entry]) => {\n          const {\n            width\n          } = entry.target.getBoundingClientRect();\n          return Math.floor(width);\n        }));\n      }));\n    }), debounceTime(16), takeUntil(this.destroy$)).subscribe(data => {\n      this.ngZone.run(() => {\n        this.listOfAutoWidth.next(data);\n      });\n    });\n  }\n  ngOnDestroy() {\n    this.destroy$.next();\n    this.destroy$.complete();\n  }\n}\n/**\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://github.com/NG-ZORRO/ng-zorro-antd/blob/master/LICENSE\n */\nclass NzTableModule {}\n/**\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://github.com/NG-ZORRO/ng-zorro-antd/blob/master/LICENSE\n */\n\n/**\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://github.com/NG-ZORRO/ng-zorro-antd/blob/master/LICENSE\n */\n\n/**\n * Generated bundle index. Do not edit.\n */\n\nexport { NzCellAlignDirective, NzCellBreakWordDirective, NzCellEllipsisDirective, NzCellFixedDirective, NzFilterTriggerComponent, NzRowExpandButtonDirective, NzRowIndentDirective, NzTableCellDirective, NzTableComponent, NzTableContentComponent, NzTableDataService, NzTableFilterComponent, NzTableFixedRowComponent, NzTableInnerDefaultComponent, NzTableInnerScrollComponent, NzTableModule, NzTableSelectionComponent, NzTableSortersComponent, NzTableStyleService, NzTableTitleFooterComponent, NzTableVirtualScrollDirective, NzTbodyComponent, NzTdAddOnComponent, NzThAddOnComponent, NzThMeasureDirective, NzThSelectionComponent, NzTheadComponent, NzTrDirective, NzTrExpandDirective, NzTrMeasureComponent };\n//# sourceMappingURL=ng-zorro-antd-table.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}