{"ast":null,"code":"import { __decorate, __metadata } from 'tslib';\nimport { FocusMonitor } from '@angular/cdk/a11y';\nimport { Directionality, BidiModule } from '@angular/cdk/bidi';\nimport { Directive, Optional, Self, Renderer2, ElementRef, Input, Component, ViewEncapsulation, ChangeDetectionStrategy, ChangeDetectorRef, ContentChildren, NgZone, isDevMode, ContentChild, NgModule } from '@angular/core';\nimport { InputBoolean, isNotNil } from 'ng-zorro-antd/core/util';\nimport { Subject, merge, EMPTY } from 'rxjs';\nimport { filter, takeUntil, startWith, switchMap, mergeMap, map } from 'rxjs/operators';\nimport { NgControl } from '@angular/forms';\nimport { Platform, PlatformModule } from '@angular/cdk/platform';\nimport { CommonModule } from '@angular/common';\nimport { NzOutletModule } from 'ng-zorro-antd/core/outlet';\nimport { NzIconModule } from 'ng-zorro-antd/icon';\nimport { NzResizeService } from 'ng-zorro-antd/core/services';\n\n/**\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://github.com/NG-ZORRO/ng-zorro-antd/blob/master/LICENSE\n */\nlet NzInputDirective = /*#__PURE__*/(() => {\n  class NzInputDirective {\n    constructor(ngControl, renderer, elementRef, directionality) {\n      this.ngControl = ngControl;\n      this.directionality = directionality;\n      this.nzBorderless = false;\n      this.nzSize = 'default';\n      this._disabled = false;\n      this.disabled$ = new Subject();\n      this.dir = 'ltr';\n      this.destroy$ = new Subject();\n      renderer.addClass(elementRef.nativeElement, 'ant-input');\n    }\n    get disabled() {\n      if (this.ngControl && this.ngControl.disabled !== null) {\n        return this.ngControl.disabled;\n      }\n      return this._disabled;\n    }\n    set disabled(value) {\n      this._disabled = value != null && `${value}` !== 'false';\n    }\n    ngOnInit() {\n      var _a, _b;\n      if (this.ngControl) {\n        (_a = this.ngControl.statusChanges) === null || _a === void 0 ? void 0 : _a.pipe(filter(() => this.ngControl.disabled !== null), takeUntil(this.destroy$)).subscribe(() => {\n          this.disabled$.next(this.ngControl.disabled);\n        });\n      }\n      this.dir = this.directionality.value;\n      (_b = this.directionality.change) === null || _b === void 0 ? void 0 : _b.pipe(takeUntil(this.destroy$)).subscribe(direction => {\n        this.dir = direction;\n      });\n    }\n    ngOnChanges(changes) {\n      const {\n        disabled\n      } = changes;\n      if (disabled) {\n        this.disabled$.next(this.disabled);\n      }\n    }\n    ngOnDestroy() {\n      this.destroy$.next();\n      this.destroy$.complete();\n    }\n  }\n  __decorate([InputBoolean(), __metadata(\"design:type\", Object)], NzInputDirective.prototype, \"nzBorderless\", void 0);\n  return NzInputDirective;\n})();\nclass NzInputGroupWhitSuffixOrPrefixDirective {\n  constructor(elementRef) {\n    this.elementRef = elementRef;\n  }\n}\nlet NzInputGroupComponent = /*#__PURE__*/(() => {\n  class NzInputGroupComponent {\n    constructor(focusMonitor, elementRef, cdr, directionality) {\n      this.focusMonitor = focusMonitor;\n      this.elementRef = elementRef;\n      this.cdr = cdr;\n      this.directionality = directionality;\n      this.nzAddOnBeforeIcon = null;\n      this.nzAddOnAfterIcon = null;\n      this.nzPrefixIcon = null;\n      this.nzSuffixIcon = null;\n      this.nzSize = 'default';\n      this.nzSearch = false;\n      this.nzCompact = false;\n      this.isLarge = false;\n      this.isSmall = false;\n      this.isAffix = false;\n      this.isAddOn = false;\n      this.focused = false;\n      this.disabled = false;\n      this.dir = 'ltr';\n      this.destroy$ = new Subject();\n    }\n    updateChildrenInputSize() {\n      if (this.listOfNzInputDirective) {\n        this.listOfNzInputDirective.forEach(item => item.nzSize = this.nzSize);\n      }\n    }\n    ngOnInit() {\n      var _a;\n      this.focusMonitor.monitor(this.elementRef, true).pipe(takeUntil(this.destroy$)).subscribe(focusOrigin => {\n        this.focused = !!focusOrigin;\n        this.cdr.markForCheck();\n      });\n      this.dir = this.directionality.value;\n      (_a = this.directionality.change) === null || _a === void 0 ? void 0 : _a.pipe(takeUntil(this.destroy$)).subscribe(direction => {\n        this.dir = direction;\n      });\n    }\n    ngAfterContentInit() {\n      this.updateChildrenInputSize();\n      const listOfInputChange$ = this.listOfNzInputDirective.changes.pipe(startWith(this.listOfNzInputDirective));\n      listOfInputChange$.pipe(switchMap(list => {\n        return merge(...[listOfInputChange$, ...list.map(input => input.disabled$)]);\n      }), mergeMap(() => listOfInputChange$), map(list => list.some(input => input.disabled)), takeUntil(this.destroy$)).subscribe(disabled => {\n        this.disabled = disabled;\n        this.cdr.markForCheck();\n      });\n    }\n    ngOnChanges(changes) {\n      const {\n        nzSize,\n        nzSuffix,\n        nzPrefix,\n        nzPrefixIcon,\n        nzSuffixIcon,\n        nzAddOnAfter,\n        nzAddOnBefore,\n        nzAddOnAfterIcon,\n        nzAddOnBeforeIcon\n      } = changes;\n      if (nzSize) {\n        this.updateChildrenInputSize();\n        this.isLarge = this.nzSize === 'large';\n        this.isSmall = this.nzSize === 'small';\n      }\n      if (nzSuffix || nzPrefix || nzPrefixIcon || nzSuffixIcon) {\n        this.isAffix = !!(this.nzSuffix || this.nzPrefix || this.nzPrefixIcon || this.nzSuffixIcon);\n      }\n      if (nzAddOnAfter || nzAddOnBefore || nzAddOnAfterIcon || nzAddOnBeforeIcon) {\n        this.isAddOn = !!(this.nzAddOnAfter || this.nzAddOnBefore || this.nzAddOnAfterIcon || this.nzAddOnBeforeIcon);\n      }\n    }\n    ngOnDestroy() {\n      this.focusMonitor.stopMonitoring(this.elementRef);\n      this.destroy$.next();\n      this.destroy$.complete();\n    }\n  }\n  __decorate([InputBoolean(), __metadata(\"design:type\", Object)], NzInputGroupComponent.prototype, \"nzSearch\", void 0);\n  __decorate([InputBoolean(), __metadata(\"design:type\", Object)], NzInputGroupComponent.prototype, \"nzCompact\", void 0);\n\n  /**\n   * Use of this source code is governed by an MIT-style license that can be\n   * found in the LICENSE file at https://github.com/NG-ZORRO/ng-zorro-antd/blob/master/LICENSE\n   */\n  return NzInputGroupComponent;\n})();\nclass NzAutosizeDirective {\n  constructor(elementRef, ngZone, platform, resizeService) {\n    this.elementRef = elementRef;\n    this.ngZone = ngZone;\n    this.platform = platform;\n    this.resizeService = resizeService;\n    this.autosize = false;\n    this.el = this.elementRef.nativeElement;\n    this.maxHeight = null;\n    this.minHeight = null;\n    this.destroy$ = new Subject();\n    this.inputGap = 10;\n  }\n  set nzAutosize(value) {\n    const isAutoSizeType = data => {\n      return typeof data !== 'string' && typeof data !== 'boolean' && (!!data.maxRows || !!data.minRows);\n    };\n    if (typeof value === 'string' || value === true) {\n      this.autosize = true;\n    } else if (isAutoSizeType(value)) {\n      this.autosize = true;\n      this.minRows = value.minRows;\n      this.maxRows = value.maxRows;\n      this.maxHeight = this.setMaxHeight();\n      this.minHeight = this.setMinHeight();\n    }\n  }\n  resizeToFitContent(force = false) {\n    this.cacheTextareaLineHeight();\n    // If we haven't determined the line-height yet, we know we're still hidden and there's no point\n    // in checking the height of the textarea.\n    if (!this.cachedLineHeight) {\n      return;\n    }\n    const textarea = this.el;\n    const value = textarea.value;\n    // Only resize if the value or minRows have changed since these calculations can be expensive.\n    if (!force && this.minRows === this.previousMinRows && value === this.previousValue) {\n      return;\n    }\n    const placeholderText = textarea.placeholder;\n    // Reset the textarea height to auto in order to shrink back to its default size.\n    // Also temporarily force overflow:hidden, so scroll bars do not interfere with calculations.\n    // Long placeholders that are wider than the textarea width may lead to a bigger scrollHeight\n    // value. To ensure that the scrollHeight is not bigger than the content, the placeholders\n    // need to be removed temporarily.\n    textarea.classList.add('nz-textarea-autosize-measuring');\n    textarea.placeholder = '';\n    let height = Math.round((textarea.scrollHeight - this.inputGap) / this.cachedLineHeight) * this.cachedLineHeight + this.inputGap;\n    if (this.maxHeight !== null && height > this.maxHeight) {\n      height = this.maxHeight;\n    }\n    if (this.minHeight !== null && height < this.minHeight) {\n      height = this.minHeight;\n    }\n    // Use the scrollHeight to know how large the textarea *would* be if fit its entire value.\n    textarea.style.height = `${height}px`;\n    textarea.classList.remove('nz-textarea-autosize-measuring');\n    textarea.placeholder = placeholderText;\n    // On Firefox resizing the textarea will prevent it from scrolling to the caret position.\n    // We need to re-set the selection in order for it to scroll to the proper position.\n    if (typeof requestAnimationFrame !== 'undefined') {\n      this.ngZone.runOutsideAngular(() => requestAnimationFrame(() => {\n        const {\n          selectionStart,\n          selectionEnd\n        } = textarea;\n        // IE will throw an \"Unspecified error\" if we try to set the selection range after the\n        // element has been removed from the DOM. Assert that the directive hasn't been destroyed\n        // between the time we requested the animation frame and when it was executed.\n        // Also note that we have to assert that the textarea is focused before we set the\n        // selection range. Setting the selection range on a non-focused textarea will cause\n        // it to receive focus on IE and Edge.\n        if (!this.destroy$.isStopped && document.activeElement === textarea) {\n          textarea.setSelectionRange(selectionStart, selectionEnd);\n        }\n      }));\n    }\n    this.previousValue = value;\n    this.previousMinRows = this.minRows;\n  }\n  cacheTextareaLineHeight() {\n    if (this.cachedLineHeight >= 0 || !this.el.parentNode) {\n      return;\n    }\n    // Use a clone element because we have to override some styles.\n    const textareaClone = this.el.cloneNode(false);\n    textareaClone.rows = 1;\n    // Use `position: absolute` so that this doesn't cause a browser layout and use\n    // `visibility: hidden` so that nothing is rendered. Clear any other styles that\n    // would affect the height.\n    textareaClone.style.position = 'absolute';\n    textareaClone.style.visibility = 'hidden';\n    textareaClone.style.border = 'none';\n    textareaClone.style.padding = '0';\n    textareaClone.style.height = '';\n    textareaClone.style.minHeight = '';\n    textareaClone.style.maxHeight = '';\n    // In Firefox it happens that textarea elements are always bigger than the specified amount\n    // of rows. This is because Firefox tries to add extra space for the horizontal scrollbar.\n    // As a workaround that removes the extra space for the scrollbar, we can just set overflow\n    // to hidden. This ensures that there is no invalid calculation of the line height.\n    // See Firefox bug report: https://bugzilla.mozilla.org/show_bug.cgi?id=33654\n    textareaClone.style.overflow = 'hidden';\n    this.el.parentNode.appendChild(textareaClone);\n    this.cachedLineHeight = textareaClone.clientHeight - this.inputGap;\n    this.el.parentNode.removeChild(textareaClone);\n    // Min and max heights have to be re-calculated if the cached line height changes\n    this.maxHeight = this.setMaxHeight();\n    this.minHeight = this.setMinHeight();\n  }\n  setMinHeight() {\n    const minHeight = this.minRows && this.cachedLineHeight ? this.minRows * this.cachedLineHeight + this.inputGap : null;\n    if (minHeight !== null) {\n      this.el.style.minHeight = `${minHeight}px`;\n    }\n    return minHeight;\n  }\n  setMaxHeight() {\n    const maxHeight = this.maxRows && this.cachedLineHeight ? this.maxRows * this.cachedLineHeight + this.inputGap : null;\n    if (maxHeight !== null) {\n      this.el.style.maxHeight = `${maxHeight}px`;\n    }\n    return maxHeight;\n  }\n  noopInputHandler() {\n    // no-op handler that ensures we're running change detection on input events.\n  }\n  ngAfterViewInit() {\n    if (this.autosize && this.platform.isBrowser) {\n      this.resizeToFitContent();\n      this.resizeService.subscribe().pipe(takeUntil(this.destroy$)).subscribe(() => this.resizeToFitContent(true));\n    }\n  }\n  ngOnDestroy() {\n    this.destroy$.next();\n    this.destroy$.complete();\n  }\n  ngDoCheck() {\n    if (this.autosize && this.platform.isBrowser) {\n      this.resizeToFitContent();\n    }\n  }\n}\n/**\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://github.com/NG-ZORRO/ng-zorro-antd/blob/master/LICENSE\n */\nclass NzInputGroupSlotComponent {\n  constructor() {\n    this.icon = null;\n    this.type = null;\n    this.template = null;\n  }\n}\n/**\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://github.com/NG-ZORRO/ng-zorro-antd/blob/master/LICENSE\n */\nclass NzTextareaCountComponent {\n  constructor(renderer, elementRef) {\n    this.renderer = renderer;\n    this.elementRef = elementRef;\n    this.nzMaxCharacterCount = 0;\n    this.nzComputeCharacterCount = v => v.length;\n    this.nzFormatter = (c, m) => `${c}` + (m > 0 ? `/${m}` : ``);\n    this.configChange$ = new Subject();\n    this.destroy$ = new Subject();\n  }\n  ngAfterContentInit() {\n    if (!this.nzInputDirective && isDevMode()) {\n      throw new Error('[nz-textarea-count]: Could not find matching textarea[nz-input] child.');\n    }\n    if (this.nzInputDirective.ngControl) {\n      const valueChanges = this.nzInputDirective.ngControl.valueChanges || EMPTY;\n      merge(valueChanges, this.configChange$).pipe(takeUntil(this.destroy$), map(() => this.nzInputDirective.ngControl.value), startWith(this.nzInputDirective.ngControl.value)).subscribe(value => {\n        this.setDataCount(value);\n      });\n    }\n  }\n  setDataCount(value) {\n    const inputValue = isNotNil(value) ? String(value) : '';\n    const currentCount = this.nzComputeCharacterCount(inputValue);\n    const dataCount = this.nzFormatter(currentCount, this.nzMaxCharacterCount);\n    this.renderer.setAttribute(this.elementRef.nativeElement, 'data-count', dataCount);\n  }\n  ngOnDestroy() {\n    this.configChange$.complete();\n    this.destroy$.next();\n    this.destroy$.complete();\n  }\n}\n/**\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://github.com/NG-ZORRO/ng-zorro-antd/blob/master/LICENSE\n */\nclass NzInputModule {}\n/**\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://github.com/NG-ZORRO/ng-zorro-antd/blob/master/LICENSE\n */\n\n/**\n * Generated bundle index. Do not edit.\n */\n\nexport { NzAutosizeDirective, NzInputDirective, NzInputGroupComponent, NzInputGroupSlotComponent, NzInputGroupWhitSuffixOrPrefixDirective, NzInputModule, NzTextareaCountComponent };\n//# sourceMappingURL=ng-zorro-antd-input.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}